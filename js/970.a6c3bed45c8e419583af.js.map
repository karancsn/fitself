{"version":3,"file":"js/970.a6c3bed45c8e419583af.js","mappings":"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","sources":["webpack://fitself/./node_modules/@oracle/oraclejet/dist/js/libs/oj/debug/ojcheckboxset.js","webpack://fitself/./node_modules/@oracle/oraclejet/dist/js/libs/oj/debug/ojradiocheckbox.js"],"sourcesContent":["/**\n * @license\n * Copyright (c) 2014, 2023, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\ndefine(['ojs/ojcomponentcore', 'ojs/ojeditablevalue', 'ojs/ojradiocheckbox', 'ojs/ojoption', 'ojs/ojcore-base', 'jquery', 'ojs/ojlogger', 'ojs/ojtranslation', 'ojs/ojlabelledbyutils'], function (ojcomponentcore, ojeditablevalue, ojradiocheckbox, ojoption, oj, $, Logger, Translations, LabeledByUtils) { 'use strict';\n\n  oj = oj && Object.prototype.hasOwnProperty.call(oj, 'default') ? oj['default'] : oj;\n  $ = $ && Object.prototype.hasOwnProperty.call($, 'default') ? $['default'] : $;\n  LabeledByUtils = LabeledByUtils && Object.prototype.hasOwnProperty.call(LabeledByUtils, 'default') ? LabeledByUtils['default'] : LabeledByUtils;\n\n  (function () {\nvar __oj_checkboxset_metadata = \n{\n  \"properties\": {\n    \"describedBy\": {\n      \"type\": \"string\"\n    },\n    \"disabled\": {\n      \"type\": \"boolean\",\n      \"value\": false\n    },\n    \"displayOptions\": {\n      \"type\": \"object\",\n      \"properties\": {\n        \"converterHint\": {\n          \"type\": \"Array<string>|string\"\n        },\n        \"helpInstruction\": {\n          \"type\": \"Array<string>|string\",\n          \"value\": [\n            \"notewindow\"\n          ]\n        },\n        \"messages\": {\n          \"type\": \"Array<string>|string\"\n        },\n        \"validatorHint\": {\n          \"type\": \"Array<string>|string\"\n        }\n      }\n    },\n    \"help\": {\n      \"type\": \"object\",\n      \"properties\": {\n        \"instruction\": {\n          \"type\": \"string\",\n          \"value\": \"\"\n        }\n      }\n    },\n    \"helpHints\": {\n      \"type\": \"object\",\n      \"properties\": {\n        \"definition\": {\n          \"type\": \"string\",\n          \"value\": \"\"\n        },\n        \"source\": {\n          \"type\": \"string\",\n          \"value\": \"\"\n        }\n      }\n    },\n    \"labelEdge\": {\n      \"type\": \"string\",\n      \"enumValues\": [\n        \"inside\",\n        \"none\",\n        \"provided\"\n      ]\n    },\n    \"labelHint\": {\n      \"type\": \"string\",\n      \"value\": \"\"\n    },\n    \"labelledBy\": {\n      \"type\": \"string\"\n    },\n    \"messagesCustom\": {\n      \"type\": \"Array<Object>\",\n      \"writeback\": true,\n      \"value\": []\n    },\n    \"optionRenderer\": {\n      \"type\": \"function\"\n    },\n    \"options\": {\n      \"type\": \"object\"\n    },\n    \"optionsKeys\": {\n      \"type\": \"object\",\n      \"properties\": {\n        \"label\": {\n          \"type\": \"string\"\n        },\n        \"value\": {\n          \"type\": \"string\"\n        }\n      }\n    },\n    \"readonly\": {\n      \"type\": \"boolean\",\n      \"value\": false\n    },\n    \"required\": {\n      \"type\": \"boolean\",\n      \"value\": false\n    },\n    \"translations\": {\n      \"type\": \"object\",\n      \"value\": {},\n      \"properties\": {\n        \"readonlyNoValue\": {\n          \"type\": \"string\"\n        },\n        \"required\": {\n          \"type\": \"object\",\n          \"properties\": {\n            \"hint\": {\n              \"type\": \"string\"\n            },\n            \"messageDetail\": {\n              \"type\": \"string\"\n            },\n            \"messageSummary\": {\n              \"type\": \"string\"\n            }\n          }\n        }\n      }\n    },\n    \"userAssistanceDensity\": {\n      \"type\": \"string\",\n      \"enumValues\": [\n        \"compact\",\n        \"efficient\",\n        \"reflow\"\n      ],\n      \"value\": \"reflow\"\n    },\n    \"valid\": {\n      \"type\": \"string\",\n      \"writeback\": true,\n      \"enumValues\": [\n        \"invalidHidden\",\n        \"invalidShown\",\n        \"pending\",\n        \"valid\"\n      ],\n      \"readOnly\": true\n    },\n    \"value\": {\n      \"type\": \"Array<any>\",\n      \"writeback\": true,\n      \"value\": []\n    }\n  },\n  \"methods\": {\n    \"getProperty\": {},\n    \"refresh\": {},\n    \"reset\": {},\n    \"setProperties\": {},\n    \"setProperty\": {},\n    \"showMessages\": {},\n    \"validate\": {},\n    \"getNodeBySubId\": {},\n    \"getSubIdByNode\": {}\n  },\n  \"events\": {\n    \"ojAnimateEnd\": {},\n    \"ojAnimateStart\": {}\n  },\n  \"extension\": {}\n};\n    __oj_checkboxset_metadata.extension._WIDGET_NAME = 'ojCheckboxset';\n    __oj_checkboxset_metadata.extension._ALIASED_PROPS = { readonly: 'readOnly' };\n    __oj_checkboxset_metadata.extension._TRACK_CHILDREN = 'immediate';\n\n    oj.CustomElementBridge.register('oj-checkboxset', {\n      metadata: oj.CollectionUtils.mergeDeep(__oj_checkboxset_metadata, {\n        properties: {\n          readonly: {\n            binding: { consume: { name: 'readonly' } }\n          },\n          userAssistanceDensity: {\n            binding: { consume: { name: 'userAssistanceDensity' } }\n          },\n          labelEdge: {\n            binding: { consume: { name: 'labelEdge' } }\n          }\n        }\n      })\n    });\n  })();\n\n  (function () {\n    /*!\n     * JET Checkboxset @VERSION\n     */\n\n    // -----------------------------------------------------------------------------\n    // \"private static members\" shared by all checkboxsets\n    // -----------------------------------------------------------------------------\n\n    // do not do a value change check in _SetValue\n    var _sValueChangeCheckFalse = { doValueChangeCheck: false };\n\n    /**\n     * @ojcomponent oj.ojCheckboxset\n     * @augments oj.editableValue\n     * @since 0.6.0\n     * @ojshortdesc A checkbox set allows the user to select one or more options from a set.\n     * @ojrole checkbox\n     * @ojrole checkboxgroup\n     * @ojrole option\n     * @ojimportmembers oj.ojDisplayOptions\n     * @ojdisplayname Checkbox Set\n     * @ojtsimport {module: \"ojdataprovider\", type: \"AMD\", imported: [\"DataProvider\"]}\n     *\n     * @ojsignature [{\n     *                target: \"Type\",\n     *                value: \"class ojCheckboxset<K, D, V =any> extends editableValue<Array<V>, ojCheckboxsetSettableProperties<K, D, V>>\",\n     *                genericParameters: [{\"name\": \"K\", \"description\": \"Type of key of the dataprovider\"}, {\"name\": \"D\", \"description\": \"Type of data from the dataprovider\"},\n     *                {\"name\": \"V\", \"description\": \"Type of each item in the value of the component\"}]\n     *               },\n     *               {\n     *                target: \"Type\",\n     *                value: \"ojCheckboxsetSettableProperties<K, D, V> extends editableValueSettableProperties<Array<V>>\",\n     *                for: \"SettableProperties\"\n     *               }\n     *              ]\n     *\n     * @ojpropertylayout {propertyGroup: \"common\", items: [\"labelHint\", \"required\", \"disabled\"]}\n     * @ojpropertylayout {propertyGroup: \"data\", items: [\"value\"]}\n     * @ojvbdefaultcolumns 6\n     * @ojvbmincolumns 2\n     *\n     * @ojoracleicon 'oj-ux-ico-checkbox-set'\n     * @ojuxspecs ['checkboxset']\n     *\n     * @classdesc\n     * <h3 id=\"checkboxsetOverview-section\">\n     *   JET Checkboxset\n     *   <a class=\"bookmarkable-link\" title=\"Bookmarkable Link\" href=\"#checkboxsetOverview-section\"></a>\n     * </h3>\n     * <p>\n     * The JET oj-checkboxset component manages a set of\n     * <code class=\"prettyprint\">oj-option</code> child elements and creates the necessary dom elements for\n     * the actual checkboxes.\n     * </p>\n     * <p>To use an oj-checkboxset, add one or more oj-option child elements for each checkbox desired.\n     * Note, if you add or remove an oj-option after the oj-checkboxset is rendered, you should call\n     * refresh() on the oj-checkboxset.\n     * Note, oj-optgroup is not a supported child element of oj-checkboxset.\n     * </p>\n     * <p>The child content can be configured via inline HTML content or a DataProvider.\n     * It is recommended that inline HTML content should only be used for static data and the DataProvider should always be used for mutable data.\n     * </p>\n     * <p>A JET Checkbox Set can be created with the following markup.</p>\n     * <pre class=\"prettyprint\">\n     * <code>\n     * &lt;oj-checkboxset>\n     *   &lt;oj-option value=\"option 1\">option 1&lt;/oj-option>\n     *   &lt;oj-option value=\"option 2\">option 2&lt;/oj-option>\n     *   &lt;oj-option value=\"option 3\">option 3&lt;/oj-option>\n     *   &lt;oj-option value=\"option 4\">option 4&lt;/oj-option>\n     * &lt;/oj-checkboxset>\n     * </code></pre>\n     * <p>A JET Checkbox Set can be created with a DataProvider.</p>\n     * <pre class=\"prettyprint\">\n     * <code>\n     * &lt;oj-checkboxset options=\"[[dataprovider]]\">\n     * &lt;/oj-checkboxset>\n     * </code></pre>\n     *\n     * <p>\n     *  You can enable and disable an oj-checkboxset,\n     *  which will enable and disable all contained checkboxes.\n     * </p>\n     * {@ojinclude \"name\":\"validationAndMessagingDoc\"}\n     *\n     * <h3 id=\"touch-section\">\n     *   Touch End User Information\n     *   <a class=\"bookmarkable-link\" title=\"Bookmarkable Link\" href=\"#touch-section\"></a>\n     * </h3>\n     *\n     * {@ojinclude \"name\":\"touchDoc\"}\n     *\n     * <h3 id=\"keyboard-section\">\n     *   Keyboard End User Information\n     *   <a class=\"bookmarkable-link\" title=\"Bookmarkable Link\" href=\"#keyboard-section\"></a>\n     * </h3>\n     *\n     * {@ojinclude \"name\":\"keyboardDoc\"}\n     *\n     * <h3 id=\"a11y-section\">\n     *   Accessibility\n     *   <a class=\"bookmarkable-link\" title=\"Bookmarkable Link\" href=\"#a11y-section\"></a>\n     * </h3>\n     *\n     * <p>JET Checkboxset takes care of setting <code class=\"prettyprint\">role=\"group\"</code>\n     * on the oj-checkboxset element.\n     *\n     * <p>\n     * {@ojinclude \"name\":\"accessibilitySetLabelEditableValue\"}\n     * {@ojinclude \"name\":\"accessibilityDisabledEditableValue\"}\n     * </p>\n     *\n     * @example <caption>Initialize the checkboxset with no attributes specified:</caption>\n     * &lt;oj-checkboxset id=\"colorCheckbox\" value=\"{{currentColor}}\">\n     *   &lt;oj-option value=\"blue\">Blue&lt;/oj-option>\n     *   &lt;oj-option value=\"green\">Green&lt;/oj-option>\n     * &lt;/oj-checkboxset>\n     *\n     * @example <caption>Initialize component and an associated oj-label component</caption>\n     * &lt;oj-label id=\"grouplabel\">Greetings&lt;/oj-label>\n     * &lt;oj-checkboxset id=\"checkboxset\" labelled-by=\"grouplabel\" value=\"{{currentGreeting}}\">\n     *   &lt;oj-option id=\"helloid\" value=\"hello\">Hello&lt;/oj-option>\n     *   &lt;oj-option id=\"bonjourid\" value=\"bonjour\"/>Bonjour&lt;/oj-option>\n     *   &lt;oj-option id=\"ciaoid\" value=\"ciao\"/>Ciao&lt;/oj-option>\n     * &lt;/oj-checkboxset>\n     * <br/>\n     * // set the value to \"ciao\". (The 'ciao' checkbox will be checked)\n     * myComp.value = [\"ciao\"];\n     */\n\n    /**\n     * Removes the checkboxset functionality completely.\n     * This will return the element back to its pre-init state.\n     *\n     * <p>This method does not accept any arguments.\n     *\n     * @method\n     * @name oj.ojCheckboxset#destroy\n     * @memberof oj.ojCheckboxset\n     * @instance\n     * @ignore\n     *\n     * @example <caption>Invoke the <code class=\"prettyprint\">destroy</code> method:</caption>\n     * $( \".selector\" ).ojCheckboxset( \"destroy\" );\n     */\n\n    //------------------------------------------------------------\n    //                              Fragments\n    //------------------------------------------------------------\n    /**\n     * <p>The &lt;oj-checkboxset> element accepts <code class=\"prettyprint\">oj-option</code> elements as children. See the [oj-option]{@link oj.ojOption} documentation for details about\n     * accepted children and slots.</p>\n     *\n     * @ojchild Default\n     * @memberof oj.ojCheckboxset\n     * @ojshortdesc The oj-checkboxset element accepts oj-option elements as children.\n     * @ojpreferredcontent [\"OptionElement\"]\n     *\n     * @example <caption>Initialize the Checkboxset with child content specified:</caption>\n     * &lt;oj-checkboxset>\n     *   &lt;oj-option value=\"check1\">Check 1&lt;/oj-option>\n     *   &lt;oj-option value=\"check2\">Check 2&lt;/oj-option>\n     *   &lt;oj-option value=\"check3\">Check 3&lt;/oj-option>\n     * &lt;/oj-checkboxset>\n     */\n\n    /**\n     * <table class=\"keyboard-table\">\n     *   <thead>\n     *     <tr>\n     *       <th>Target</th>\n     *       <th>Gesture</th>\n     *       <th>Action</th>\n     *     </tr>\n     *   </thead>\n     *   <tbody>\n     *    <tr>\n     *       <td>Checkbox</td>\n     *       <td><kbd>Tap</kbd></td>\n     *       <td> Select/unselect the checkbox</td>\n     *     </tr>\n     *     <tr>\n     *       <td>Checkbox's Label</td>\n     *       <td><kbd>Tap</kbd></td>\n     *       <td> Select/unselect the corresponding checkbox</td>\n     *    </tr>\n     *     <tr>\n     *       <td>Checkbox or Label</td>\n     *       <td><kbd>Press & Hold</kbd></td>\n     *       <td>If hints, help.instruction or messages exist in a notewindow,\n     *           pop up the notewindow.</td>\n     *    </tr>\n     *   </tbody>\n     *  </table>\n     *\n     *\n     * @ojfragment touchDoc - Used in touch gesture section of classdesc, and standalone gesture doc\n     * @memberof oj.ojCheckboxset\n     */\n\n    /**\n     * <table class=\"keyboard-table\">\n     *   <thead>\n     *     <tr>\n     *       <th>Target</th>\n     *       <th>Key</th>\n     *       <th>Action</th>\n     *     </tr>\n     *   </thead>\n     *   <tbody>\n     *     <tr>\n     *       <td>Checkboxset</td>\n     *       <td><kbd>Tab In</kbd></td>\n     *       <td>Set focus to the first focusable checkbox in the checkboxset.\n     *       Disabled checkboxes are not focusable.\n     *       If hints, helpInstruction or messages exist in a notewindow,\n     *        pop up the notewindow.</td>\n     *     </tr>\n     *     <tr>\n     *       <td>Checkbox</td>\n     *       <td><kbd>Space</kbd></td>\n     *       <td>Toggles the checkbox; Iff the checkbox is unselected, it will select it and vice versa.</td>\n     *     </tr>\n     *    <tr>\n     *       <td>Checkbox</td>\n     *       <td><kbd>Tab</kbd></td>\n     *       <td>Sets focus to the next focusable checkbox in the checkboxset.\n     *        Disabled checkboxes are not focusable. If the target is the last focusable checkbox in the\n     *        checkboxset, focus goes to the next focusable item after the oj-checkboxset.</td>\n     *     </tr>\n     *    <tr>\n     *       <td>Checkbox</td>\n     *       <td><kbd>Shift+Tab</kbd></td>\n     *       <td>Sets focus to the previous focusable checkbox in the checkboxset.\n     *        Disabled checkboxes are not focusable. If the target is the first focusable checkbox in the\n     *        checkboxset, focus goes to the previous focusable item before the oj-checkboxset.</td>\n     *     </tr>\n     *   </tbody>\n     * </table>\n     *\n     *\n     * @ojfragment keyboardDoc - Used in keyboard section of classdesc, and standalone gesture doc\n     * @memberof oj.ojCheckboxset\n     */\n    //--------------------------------------------------------\n    //                   SUB-IDS\n    //--------------------------------------------------------\n    /**\n     * <p>Sub-ID for the checkboxset's checkboxes.\n     *\n     * @ojsubid oj-checkboxset-inputs\n     * @deprecated 3.0.0 Since the application supplies the input elements, it can supply a unique ID by which the input elements can be accessed.\n     * @ignore\n     * @memberof oj.ojCheckboxset\n     * @example <caption>Get the nodes for the checkboxes:</caption>\n     * var nodes = myComp.getNodeBySubId('oj-checkboxset-inputs');\n     */\n    //------------------------------------------------------\n    //                  Styling Start\n    //------------------------------------------------------\n    /**\n     * Use this style class to lay out the checkboxes in a column. This is the default.\n     * @ojstyleclass oj-choice-direction-column\n     * @ojdisplayname Column Layout\n     * @memberof oj.ojCheckboxset\n     * @ojtsexample\n     * &lt;oj-checkboxset id=\"checkboxsetId\" class=\"oj-choice-direction-column\">\n     *   &lt;!-- Content -->\n     * &lt;/oj-checkboxset>\n     */\n    /**\n     * Use this style class to lay out the checkboxes in a row.\n     * @ojstyleclass oj-choice-direction-row\n     * @ojdisplayname Row Layout\n     * @memberof oj.ojCheckboxset\n     * @ojtsexample\n     * &lt;oj-checkboxset id=\"checkboxsetId\" class=\"oj-choice-direction-row\">\n     *   &lt;!-- Content -->\n     * &lt;/oj-checkboxset>\n     */\n    /**\n     * Use this style class if you don't want the chrome around the set.\n     * @ojstyleclass oj-checkboxset-no-chrome\n     * @ojdisplayname No Chrome\n     * @memberof oj.ojCheckboxset\n     * @ojtsexample\n     * &lt;oj-checkboxset id=\"checkboxsetId\" class=\"oj-checkboxset-no-chrome\">\n     *   &lt;!-- Content -->\n     * &lt;/oj-checkboxset>\n     */\n    /**\n     * Use this style class to order the checkbox at the start and label text at the end, even if a theme has a different default order.\n     * @ojstyleclass oj-checkboxset-input-start\n     * @ojdisplayname Input Start\n     * @memberof oj.ojCheckboxset\n     * @ojtsexample\n     * &lt;oj-checkboxset id=\"checkboxsetId\" class=\"oj-checkboxset-input-start\">\n     *   &lt;!-- Content -->\n     * &lt;/oj-checkboxset>\n     */\n    /**\n     * Use this style class to order the checkbox at the end and the label text at the start, even if a theme has a different default order.\n     * @ojstyleclass oj-checkboxset-input-end\n     * @ojdisplayname Input End\n     * @memberof oj.ojCheckboxset\n     * @ojtsexample\n     * &lt;oj-checkboxset id=\"checkboxsetId\" class=\"oj-checkboxset-input-end\">\n     *   &lt;!-- Content -->\n     * &lt;/oj-checkboxset>\n     */\n\n    oj.__registerWidget('oj.ojCheckboxset', $.oj.editableValue, {\n      version: '1.0.0',\n      defaultElement: '<div>',\n      widgetEventPrefix: 'oj',\n\n      /**\n       * @expose\n       * @private\n       */\n      _WRAPPER_CLASS_NAMES: 'oj-checkboxset-wrapper oj-form-control-container',\n\n      options: {\n        /**\n         * <p>\n         * Disabled <code class=\"prettyprint\">true</code> disables the component and disables\n         * all the inputs/labels.\n         * Disabled <code class=\"prettyprint\">false</code> enables the component, and leaves the inputs\n         * disabled state as it is in the dom.\n         * <p>\n         *\n         * @example <caption>Initialize component with <code class=\"prettyprint\">disabled</code> attribute:</caption>\n         * &lt;oj-checkboxset disabled>\n         *   &lt;oj-option value=\"blue\">Blue&lt;/oj-option>\n         * &lt;/oj-checkboxset>\n         *\n         * @example <caption>Get or set the <code class=\"prettyprint\">disabled</code> property after initialization:</caption>\n         * // getter\n         * var disabled = myComp.disabled;\n         *\n         * // setter\n         * myComp.disabled = false;\n         *\n         * @expose\n         * @type {boolean}\n         * @default false\n         * @ojshortdesc Specifies if the component is disabled. If true, then all of its inputs and labels are also disabled. See the Help documentation for more information.\n         * @public\n         * @instance\n         * @memberof oj.ojCheckboxset\n         */\n        disabled: false,\n        /**\n         * labelled-by is used to establish a relationship between this component and another element.\n         * A common use is to tie the oj-label and the oj-checkboxset together for accessibility.\n         * The oj-label custom element has an id, and you use the labelled-by attribute\n         * to tie the two components together to facilitate correct screen reader behavior.\n         *\n         * @example <caption>Initialize component with <code class=\"prettyprint\">labelled-by</code> attribute:</caption>\n         * &lt;oj-label id=\"labelId\">Name:&lt;/oj-label>\n         * &lt;oj-checkboxset labelled-by=\"labelId\">\n         *   &lt;oj-option value=\"blue\">Blue&lt;/oj-option>\n         * &lt;/oj-checkboxset>\n         *\n         * @example <caption>Get or set the <code class=\"prettyprint\">labelledBy</code> property after initialization:</caption>\n         * // getter\n         * var disabled = myComp.labelledBy;\n         *\n         * // setter\n         * myComp.labelledBy = \"labelId\";\n         *\n         * @expose\n         * @type {string|null}\n         * @ojshortdesc Establishes a relationship between this component and another element, typically an oj-label custom element. See the Help documenation for more information.\n         * @public\n         * @instance\n         * @memberof oj.ojCheckboxset\n         */\n        labelledBy: null,\n        /**\n         * Whether the component is readonly. The readonly property sets or returns whether an element is readonly, or not.\n         * A readonly element cannot be modified. However, a user can tab to it, highlight it, focus on it, and copy the text from it.\n         * If you want to prevent the user from interacting with the element, use the disabled property instead.\n         * <p>\n         * The default value for readonly is false. However, if the form component is a descendent of\n         * <code class=\"prettyprint\">oj-form-layout</code>, the default value for readonly could come from the\n         * <code class=\"prettyprint\">oj-form-layout</code> component's readonly attribute.\n         * The <code class=\"prettyprint\">oj-form-layout</code> uses the\n         * <a href=\"MetadataTypes.html#PropertyBinding\">MetadataTypes.PropertyBinding</a>\n         * <code class=\"prettyprint\">provide</code> property to provide its\n         * <code class=\"prettyprint\">readonly</code>\n         * attribute value to be consumed by descendent components.\n         * The form components are configured to consume the readonly property if an ancestor provides it and\n         * it is not explicitly set.\n         * For example, if the oj-form-layout's readonly attribute is set to true, and a descendent form component does\n         * not have its readonly attribute set, the form component's readonly will be true.\n         * </p>\n         *\n         * @example <caption>Initialize component with <code class=\"prettyprint\">readonly</code> attribute:</caption>\n         * &lt;oj-checkboxset readonly>&lt;/oj-checkboxset>\n         *\n         * @example <caption>Get or set the <code class=\"prettyprint\">readonly</code> property after initialization:</caption>\n         * // Getter\n         * var readonly = myComponent.readonly;\n         *\n         * // Setter\n         * myComponent.readonly = false;\n         *\n         * @default false\n         * @access public\n         * @expose\n         * @type {?boolean}\n         * @ojshortdesc Specifies whether the component is read-only. A read-only element cannot be modified, but user interaction is allowed. See the Help documentation for more information.\n         * @name readonly\n         * @instance\n         * @memberof oj.ojCheckboxset\n         */\n        readOnly: false,\n        /**\n         * @typedef {Object} oj.ojCheckboxset.OptionContext\n         * @property {Element} component A reference to the Checkboxset element.\n         * @property {number} index The index of the option, where 0 is the index of the first option.\n         * @property {Object} data The data object for the option.\n         * @ojsignature [{target:\"Type\", value:\"<D>\", for:\"genericTypeParameters\"},\n         *               {target:\"Type\", value:\"D\", for:\"data\"}]\n         */\n        /**\n         * {@ojinclude \"name\":\"checkboxsetCommonOptionRenderer\"}\n         * @name optionRenderer\n         * @ojshortdesc The renderer function that renders the content of each option.\n         * @expose\n         * @memberof oj.ojCheckboxset\n         * @instance\n         * @type {null|function(Object):Object}\n         * @ojsignature { target: \"Type\",\n         *                value: \"?((param0: oj.ojCheckboxset.OptionContext<D>) => Element)|null\",\n         *                jsdocOverride: true}\n         * @default null\n         * @example <caption>Initialize the checkboxset with a renderer:</caption>\n         * &lt;oj-checkboxset option-renderer=\"[[optionRenderer]]\">&lt;/oj-checkboxset>\n         * @example var optionRenderer = function(context) {\n         *            var ojOption = document.createElement('oj-option');\n         *            // Set the textContent or append other child nodes\n         *            ojOption.textContent = context.data['FIRST_NAME'] + ' ' + context.data['LAST_NAME'];\n         *            return ojOption;\n         *          };\n         */\n        /**\n         * The renderer function that renders each option.\n         * The function should return an oj-option element.\n         * <p>It is not necessary to set the \"value\" attribute on the oj-option as it is available from the options data.</p>\n         * <p>\n         * See <a href=\"#options\">options</a>\n         * and <a href=\"#optionsKeys\">options-keys</a> for configuring option label and value.\n         * </p>\n         *\n         * <p>The context parameter passed to the renderer contains the following keys:</p>\n         * <table class=\"keyboard-table\">\n         *   <thead>\n         *     <tr>\n         *       <th>Key</th>\n         *       <th>Description</th>\n         *     </tr>\n         *   </thead>\n         *   <tbody>\n         *     <tr>\n         *       <td><kbd>component</kbd></td>\n         *       <td>A reference to the Checkboxset element.</td>\n         *     </tr>\n         *     <tr>\n         *       <td><kbd>index</kbd></td>\n         *       <td>The index of the option, where 0 is the index of the first option.</td>\n         *     </tr>\n         *     <tr>\n         *       <td><kbd>data</kbd></td>\n         *       <td>The data object for the option.</td>\n         *     </tr>\n         *   </tbody>\n         * </table>\n         *\n         * @expose\n         * @memberof oj.ojCheckboxset\n         * @instance\n         * @ojfragment checkboxsetCommonOptionRenderer\n         */\n        optionRenderer: null,\n\n        /**\n         * @typedef {Object} oj.ojCheckboxset.Option\n         * @property {boolean=} disabled Option item is disabled.\n         * @property {string=} label The display label for the option item. If it's missing, string(value) will be used.\n         * @property {any} value The value of the option item.\n         */\n        /**\n         * {@ojinclude \"name\":\"checkboxsetCommonOptions\"}\n         *\n         * @name options\n         * @ojshortdesc The option items for the checkbox set.\n         * @expose\n         * @access public\n         * @instance\n         * @type {Object|null}\n         * @ojsignature { target: \"Type\",\n         *                value: \"DataProvider<K, D>|null\",\n         *                jsdocOverride: true}\n         * @default null\n         * @memberof oj.ojCheckboxset\n         *\n         * @example <caption>Initialize the Checkboxset with a data provider and data mapping:</caption>\n         * &lt;oj-checkboxset options=\"[[dataProvider]]\">&lt;/oj-checkboxset>\n         *\n         * @example <caption>Use simple DataProvider if data has value and label properties.</caption>\n         * var dataArray = [\n         *            {value: 'Id 1', label: 'Name 1'},\n         *            {value: 'Id 2', label: 'Name 2'},\n         *            {value: 'Id 3', label: 'Name 3'}];\n         *\n         * var dataProvider = new oj.ArrayDataProvider(dataArray, {keyAttributes: 'value'});\n         *\n         * @example <caption>Data mapping can be used if data doesn't have value and label properties.</caption>\n         * // actual field names are \"id\" and \"name\"\n         * var dataArray = [\n         *            {id: 'Id 1', name: 'Name 1'},\n         *            {id: 'Id 2', name: 'Name 2'},\n         *            {id: 'Id 3', name: 'Name 3'}];\n         *\n         * // In mapfields, map \"name\" to \"label\" and \"id\" to \"value\"\n         * var mapFields = function(item) {\n         *   var data = item['data'];\n         *   var mappedItem = {};\n         *   mappedItem['data'] = {};\n         *   mappedItem['data']['label'] = data['name'];\n         *   mappedItem['data']['value'] = data['id'];\n         *   mappedItem['metadata'] = {'key': data['id']};\n         *   return mappedItem;\n         * };\n         * var dataMapping = {'mapFields': mapFields};\n         *\n         * var arrayDataProvider = new oj.ArrayDataProvider(dataArray, {keyAttributes: 'id'});\n         * var dataProvider = new oj.ListDataProviderView(arrayDataProvider, {'dataMapping': dataMapping});\n         */\n        /**\n         * A data provider that returns the option items for the Checkboxset.\n         * This attribute can be used instead of providing a list of <code class=\"prettyprint\">oj-option</code> child elements of the Checkboxset element.\n         * <p>This data provider must implement <a href=\"DataProvider.html\">DataProvider</a>.\n         *   <ul>\n         *   <li><code class=\"prettyprint\">value</code> in <code class=\"prettyprint\">oj.ojCheckboxset.Option</code> must be the row key in the data provider.</li>\n         *   <li>All rows will be displayed in the Checkboxset.</li>\n         *   </ul>\n         * </p>\n         *\n         * @expose\n         * @memberof oj.ojCheckboxset\n         * @instance\n         * @ojfragment checkboxsetCommonOptions\n         */\n        options: null,\n\n        /**\n         * @typedef {Object} oj.ojCheckboxset.OptionsKeys\n         * @property {?string=} label The key name for the label.\n         * @property {?string=} value The key name for the value.\n         */\n        /**\n         * {@ojinclude \"name\":\"checkboxsetCommonOptionsKeys\"}\n         *\n         * @example <caption>Initialize the Checkboxset with <code class=\"prettyprint\">options-keys</code> specified. This allows the key names to be redefined in the options array.</caption>\n         * &lt;oj-checkboxset options-keys=\"[[optionsKeys]]\">&lt;/oj-checkboxset>\n         * @example var optionsKeys = {value : \"state_abbr\", label : \"state_name\"};\n         *\n         * @name optionsKeys\n         * @ojshortdesc Specify the key names to use in the options array.  Depending on options-keys means that the signature of the data does not match what is supported by the options attribute.\n         * @expose\n         * @access public\n         * @instance\n         * @type {?Object}\n         * @ojsignature { target: \"Type\",\n         *                value: \"?oj.ojCheckboxset.OptionsKeys\",\n         *                jsdocOverride: true}\n         * @default null\n         * @memberof oj.ojCheckboxset\n         */\n        /**\n         * Specify the key names to use in the options array.\n         * <p>Depending on options-keys means that the signature of the data does not match what is supported by the options attribute. When using Typescript, this would result in a compilation error.</p>\n         * <p>Best practice is to use a <a href=\"ListDataProviderView.html\">ListDataProviderView</a> with data mapping as a replacement.</p>\n         * <p>However, for the app that must fetch data from a REST endpoint where the data fields do not match those that are supported by the options attribute, you may use the options-keys with any dataProvider that implements <a href=\"DataProvider.html\">DataProvider</a> interface.</p>\n         *\n         * @expose\n         * @access public\n         * @instance\n         * @memberof oj.ojCheckboxset\n         * @ojfragment checkboxsetCommonOptionsKeys\n         */\n        optionsKeys: {\n          /**\n           * The key name for the label.\n           *\n           * @name optionsKeys.label\n           * @expose\n           * @public\n           * @instance\n           * @memberof! oj.ojCheckboxset\n           * @type {?string}\n           * @ojsignature { target: \"Type\",\n           *                value: \"?\"}\n           * @default null\n           */\n          /**\n           * The key name for the value.\n           *\n           * @name optionsKeys.value\n           * @expose\n           * @public\n           * @instance\n           * @memberof! oj.ojCheckboxset\n           * @type {?string}\n           * @ojsignature { target: \"Type\",\n           *                value: \"?\"}\n           * @default null\n           */\n        },\n\n        /**\n         * <p>\n         * This property set to <code class=\"prettyprint\">false</code> implies that a value is not required to be provided by the user.\n         * This is the default.\n         * This property set to <code class=\"prettyprint\">true</code> implies that a value is required to be provided by the user.\n         * </p>\n         * <p>\n         * In the Redwood theme, by default, a Required text is rendered inline when the field is empty.\n         * If user-assistance-density is 'compact', it will show on the label as an icon.\n         * In the Alta theme the input's label will render a required icon.\n         * </p>\n         * <p>The Required error text is based on Redwood UX designs, and it is not recommended that\n         * it be changed.\n         * To override the required error message,\n         * use the <code class=\"prettyprint\">translations.required</code> attribute.\n         * The component's label text is passed in as a token {label} and can be used in the message detail.\n         * </p>\n         * <p>When required is set to true, an implicit\n         * required validator is created, i.e.,\n         * <code class=\"prettyprint\">new RequiredValidator()</code>. The required validator is the only\n         * validator to run during initial render, and its error is not shown to the user at this time;\n         * this is called deferred validation. The required validator also runs during normal validation;\n         * this is when the errors are shown to the user.\n         * See the <a href=\"#validation-section\">Validation and Messaging</a> section for details.\n         * </p>\n         * <p>\n         * When the <code class=\"prettyprint\">required</code> property changes due to programmatic intervention,\n         * the component may clear component messages and run validation, based on the current state it's in. </br>\n         *\n         * <h4>Running Validation when required property changes</h4>\n         * <ul>\n         * <li>if component is valid when required is set to true, then it runs deferred validation on\n         * the value property. If the field is empty, the valid state is invalidHidden. No errors are\n         * shown to the user.\n         * </li>\n         * <li>if component is invalid and has deferred messages when required is set to false, then\n         * component messages are cleared (messages-custom messages are not cleared)\n         * but no deferred validation is run because required is false.\n         * </li>\n         * <li>if component is invalid and currently showing invalid messages when required is set, then\n         * component messages are cleared and normal validation is run using the current display value.\n         * <ul>\n         *   <li>if there are validation errors, then <code class=\"prettyprint\">value</code>\n         *   property is not updated and the error is shown.\n         *   </li>\n         *   <li>if no errors result from the validation, the <code class=\"prettyprint\">value</code>\n         *   property is updated; page author can listen to the <code class=\"prettyprint\">valueChanged</code>\n         *   event on the component to clear custom errors.</li>\n         * </ul>\n         * </li>\n         * </ul>\n         *\n         * <h4>Clearing Messages when required property changes</h4>\n         * <ul>\n         * <li>Only messages created by the component, like validation messages, are cleared when the required property changes.</li>\n         * <li><code class=\"prettyprint\">messagesCustom</code> property is not cleared.</li>\n         * </ul>\n         *\n         * </p>\n         *\n         * @example <caption>Initialize the component with the <code class=\"prettyprint\">required</code> attribute:</caption>\n         * &lt;oj-checkboxset required>\n         *   &lt;oj-option value=\"blue\">Blue&lt;/oj-option>\n         * &lt;/oj-checkboxset>\n         *\n         * @example <caption>Customize messages and hints used by implicit required validator when\n         * <code class=\"prettyprint\">required</code> option is set:</caption>\n         * &lt;oj-checkboxset required value=\"{{colors}}\"\n         *                    translations='{\"required\":\n         *                                    {\"hint\": \"custom: check at least one value\",\n         *                                     \"messageSummary\": \"custom: \\'{label}\\' is Required\",\n         *                                     \"messageDetail\", \"custom: please check at least one value for \\'{label}\\'\"}}'>\n         *   &lt;oj-option value=\"blue\">Blue&lt;/oj-option>\n         * &lt;/oj-checkboxset>\n         *\n         * @example <caption>Get or set the <code class=\"prettyprint\">required</code> property after initialization:</caption>\n         * // getter\n         * var required = myComp.required;\n         *\n         * // setter\n         * myComp.required = false;\n         *\n         * @expose\n         * @access public\n         * @instance\n         * @memberof oj.ojCheckboxset\n         * @type {boolean}\n         * @ojshortdesc Specifies whether the component is required or optional. See the Help documentation for more information.\n         * @default false\n         * @since 0.7.0\n         * @see #translations\n         */\n        required: false,\n        /**\n         * The value of the component.\n         *\n         * <p>\n         * When <code class=\"prettyprint\">value</code> is set to <code class=\"prettyprint\">null</code>,\n         * it will be converted to the default value [].\n         * When <code class=\"prettyprint\">value</code> property changes due to programmatic\n         * intervention, the component always clears all messages and runs deferred validation, and\n         * always refreshes UI display value.</br>\n         *\n         * <h4>Clearing Messages</h4>\n         * <ul>\n         * <li>All messages are cleared. This includes\n         * the <code class=\"prettyprint\">messagesCustom</code> property.</li>\n         * </ul>\n         *\n         *\n         * <h4>Running Validation</h4>\n         * <ul>\n         * <li>component always runs deferred validation</li>\n         * </ul>\n         * </p>\n         *\n         * @example <caption>Initialize the component with the <code class=\"prettyprint\">value</code> attribute specified:</caption>\n         * &lt;oj-checkboxset required value='[\"coffee\"]'>\n         *   &lt;oj-option value=\"coffee\">Coffee&lt;/oj-option>\n         *   &lt;oj-option value=\"tea\">Tea&lt;/oj-option>\n         * &lt;/oj-checkboxset>\n         * @example <caption>Get or set <code class=\"prettyprint\">value</code> option, after initialization:</caption>\n         * // Getter: returns [\"coffee\"]\n         * var val = myComp.value;\n         * // Setter: sets [\"coffee\", \"tea\"]\n         * myComp.value = [\"coffee\", \"tea\"];\n         *\n         * @expose\n         * @access public\n         * @instance\n         * @memberof oj.ojCheckboxset\n         * @ojwriteback\n         * @default []\n         * @type {Array.<any>}\n         * @ojsignature [{target: \"Type\", value: \"Array<V>|null\"}]\n         * @ojshortdesc An array that represents the value of the component. See the Help documentation for more information.\n         * @ojeventgroup common\n         */\n        value: []\n      },\n      /** ** start Public APIs ****/\n\n      /**\n       * Refreshes the checkboxset\n       * <p>A <code class=\"prettyprint\">refresh()</code> or re-init is required\n       * when a checkboxset is programatically changed, like in the following circumstances:\n       * <ul>\n       *   <li>After oj-options are added or removed.</li>\n       * </ul>\n       *\n       * @example <caption>Invoke the <code class=\"prettyprint\">refresh</code> method:</caption>\n       * myComp.refresh();\n       *\n       * @expose\n       * @public\n       * @return {void}\n       * @ojshortdesc Refreshes the checkbox set. A refresh is required after a checkbox set is programmatically changed. See the Help documentation for more information.\n       * @memberof oj.ojCheckboxset\n       * @instance\n       */\n      refresh: function () {\n        this._super();\n        this._setup();\n      },\n      /**\n       * Returns a jQuery object containing the element visually representing the checkboxset.\n       *\n       * <p>This method does not accept any arguments.\n       *\n       * @expose\n       * @memberof oj.ojCheckboxset\n       * @instance\n       * @public\n       * @return {jQuery} the checkbox\n       * @ignore\n       */\n      widget: function () {\n        return this.uiCheckboxset;\n      },\n      /**\n       * Validates the component's display value using all validators registered on\n       * the component and updates the <code class=\"prettyprint\">value</code> option by performing the\n       * following steps.\n       *\n       * <p>\n       * <ol>\n       * <li>All messages are cleared, including custom messages added by the app. </li>\n       * <li>The implicit\n       * required validator is run if the component is marked required.</li>\n       * <li>At the end of validation if there are errors, the messages are shown.\n       * If there were no errors, then the\n       * <code class=\"prettyprint\">value</code> property is updated.</li>\n       * </ol>\n       *\n       * @example <caption>Validate component using its current value.</caption>\n       * myComp.validate();\n       * @example <caption>Validate component and use the Promise's resolved state.</caption>\n       * myComp.validate().then(\n       *  function(result) {\n       *    if(result === \"valid\")\n       *    {\n       *      submitForm();\n       *    }\n       *  });\n       * @return {Promise.<string>} Promise resolves to \"valid\" if\n       * the component passed all validations.\n       * The Promise resolves to \"invalid\" if there were validation errors.\n       *\n       * @method\n       * @access public\n       * @expose\n       * @ojshortdesc Validates the component's display value using all validators registered on the component. If there are no validation errors. then the value is updated. See the Help documentation for more information.\n       * @instance\n       * @memberof oj.ojCheckboxset\n       * @since 4.0.0\n       *\n       */\n      validate: ojeditablevalue.EditableValueUtils.validate,\n\n      /** ** end Public APIs ****/\n\n      /** ** start internal widget functions ****/\n\n      /**\n       * Overridden to set the options.value. When constructorOptions value is undefined,\n       * we read the CHECKED options on the checkboxes and build the value array from that.\n       *\n       * @memberof oj.ojCheckboxset\n       * @instance\n       * @protected\n       */\n      _InitOptions: function (originalDefaults, constructorOptions) {\n        var checkedValues = [];\n        var selectedCheckbox;\n        var domValue;\n        var props = [\n          { attribute: 'disabled', validateOption: true },\n          { attribute: 'readonly', option: 'readOnly', validateOption: true },\n          { attribute: 'title' },\n          // {attribute: \"value\", \"defaultValue\": null},  // code below sets value\n          { attribute: 'required', coerceDomValue: true, validateOption: true }\n        ];\n\n        this._super(originalDefaults, constructorOptions);\n\n        if (!this._IsCustomElement()) {\n          ojeditablevalue.EditableValueUtils.initializeOptionsFromDom(props, constructorOptions, this);\n        }\n\n        // component, app, and constructor are merged into this.options.option by the time _InitOptions\n        // is called. Let's take this example:\n        // component (widget) default - 'foo'<br/>\n        // app default - 'bar'<br/>\n        // dom  - 'lucy'<br/>\n        // constructorOptions['value'] - undefined<br/>\n        // this.options.option is set to 'bar' initially. We don't want to just take this value, because\n        // we want DOM value to win over the app and components default if DOM is set.\n        // Therefore, the component needs to check if the constructorOptions['value'] is\n        // undefined and if so, set value option to 'lucy' (the DOM value in this example). <br/>\n        //\n        // use DOM value if constructorOptions is undefined. if DOM value is undefined, then\n        // leave this.options[\"value\"] alone since it's the merged app/widget default at this point.\n        if (!this._IsCustomElement()) {\n          if (constructorOptions.value === undefined) {\n            // constructor option for value is undefined. Then we check the dom.\n            this.$checkboxes = this._findCheckboxesWithMatchingName();\n            selectedCheckbox = this.$checkboxes.filter(':checked');\n            if (selectedCheckbox.length > 0) {\n              selectedCheckbox.each(function () {\n                checkedValues.push($(this).val());\n              });\n              domValue = checkedValues;\n\n              // when defaulting from DOM we want to trigger optionChange to writeback new value\n\n              this.option('value', domValue, { _context: { writeback: true, internalSet: true } });\n            }\n            // if nothing is checked, we leave this.options[\"value\"] as it is if not undefined, else\n            // the widget's default is [].\n            if (this.options.value === undefined) {\n              this.options.value = [];\n            }\n          } else {\n            this._checkValueType(this.options.value);\n          }\n        } else {\n          this._checkValueType(this.options.value);\n        }\n      },\n      /**\n       * After _ComponentCreate and _AfterCreate,\n       * the widget should be 100% set up. this._super should be called first.\n       * @override\n       * @protected\n       * @memberof oj.ojCheckboxset\n       * @instance\n       */\n      _ComponentCreate: function () {\n        const $element = this.element;\n        this._super();\n        // first check to see if element is NOT a fieldset. If fieldset, throw error.\n        if ($element.is('fieldset')) {\n          throw new Error('ojCheckboxset cannot be bound to a fieldset. Use a div instead.');\n        }\n\n        // since the oj-option renderer uses the oj-checkboxset ID for the name\n        // attribute of the rendered chekcboxes, let's make sure the checkboxset\n        // has an ID\n        $element.uniqueId();\n        // Retrieve the tabindex from the container and store it in an instance variable.\n        // Also we need to remove the tabindex from the container so that it will not receive\n        // focus\n        this._externalTabIndex = this.element.attr('tabindex') || 0;\n        this.element.removeAttr('tabindex');\n        // Async step that generates oj-option if DateProvider is used.\n        // RadioCheckboxUtils will set this._optionsDataProvider, this._optionsDataListener\n        // and this._optionsDataArray.\n        oj.RadioCheckboxUtils.generateOptionsFromData.call(this);\n\n        // Continue processing for the static oj-option case and set up the component itself\n        this._processOjOptions();\n        // The processOjOptions renders input/label, so we need to go through and\n        // get the this.$checkboxes after this is called.\n        this.$checkboxes = this._findCheckboxesWithMatchingName();\n        // Turn each checkbox into ojCheckbox. Do this first, since we need it\n        // in calls from 'create'. Also, since ojCheckboxSet delegates to the _ojRadioCheckbox\n        // component, and we need to mark this as an internal node so that oj.Components.getComponentElementByNode\n        // knows it is an internal component in this case, not a stand-alone component\n        this.$checkboxes._ojRadioCheckbox().attr('data-oj-internal', '');\n\n        // keep the root dom element and slots as is, and add a wrapper dom underneath it. This way we can\n        // have one div around all the inputs and labels, and for inline messaging we can have another\n        // div around the inline messaging content. And we can style the borders of the two boxes differently.\n        this.uiCheckboxset = $element.addClass('oj-checkboxset oj-component').attr('role', 'group');\n        // need to grab all elements using contents first and then do filter because jquery children will automatically\n        // exclude all comment and text nodes\n        const $childNodes = $element.contents().filter(function () {\n          return !(this.getAttribute && this.getAttribute('slot') === 'contextMenu');\n        });\n        // When using dataprovider, the childNodes will not be generated yet.\n        // So, in that case append the wrapper directly to the element.\n        if ($childNodes.length > 0) {\n          $childNodes.wrapAll(`<div class='${this._WRAPPER_CLASS_NAMES}'></div>`); // @HTMLUpdateOK\n        } else {\n          $element.append(`<div class='${this._WRAPPER_CLASS_NAMES}'></div>`); // @HTMLUpdateOK\n        }\n\n        // if readonly, set tabindex on the wrapper\n        this._updateReadonlyState();\n        this._on(this._events);\n        this._setup();\n      },\n\n      /**\n       * Resets this.checkboxes. This is called at the beginning of a refresh in EditableValue\n       * @override\n       * @memberof oj.ojCheckboxset\n       * @instance\n       * @protected\n       */\n      _ResetComponentState: function () {\n        // we could have added, removed, or modified radios, so we need to re-find all the\n        // oj-options, inputs on refresh and turn the ones that aren't already\n        // ojRadioCheckboxes into them.\n        this._processOjOptions();\n        this.$checkboxes = this._findCheckboxesWithMatchingName();\n\n        // we have a rule for refresh: if we have a public API for it, then the app dev has to use the\n        // option, and not expect changing the dom will update the state with refresh.\n        // However, ojCheckboxset does not expose a public API for the individual checkbox's disabled state\n        // to the app developer. Our private ojRadioCheckbox component has a disabled option that\n        // our code has access to.\n        // For each checkbox, we need to look at the disabled attribute dom and update the\n        // ojradiocheckbox's disabled option.\n\n        // !! ensures it is a boolean\n        // update the private ojradiocheckbox component's disabled option to keep it in sync with the dom\n        this.$checkboxes.filter('.oj-checkbox').each(function () {\n          var disabledValue =\n            $(this).attr('disabled') !== undefined ? !!$(this).prop('disabled') : false;\n\n          $(this)._ojRadioCheckbox('option', 'disabled', disabledValue);\n        });\n\n        // no need to refresh the ojRadioCheckbox's that exist since we have options for everything.\n        // of the type=radio inputs that are not yet ojRadioCheckboxs, make them ojRadioCheckboxes.\n\n        // create ojRadioCheckboxes on any new ones.\n        this.$checkboxes.not('.oj-checkbox')._ojRadioCheckbox();\n      },\n\n      /**\n       * @override\n       * @memberof oj.ojCheckboxset\n       * @instance\n       * @protected\n       * @since 5.0.0\n       */\n      GetFocusElement: function () {\n        // JET-48463 - oj-table issue where focus is lost\n        // GetFocusElement() needs to return the correct readonly element\n        // If _GetReadonlyFocusElement() returns null, fallback to the\n        // enabled element logic.\n        if (this.options.readOnly === true) {\n          const readonlyFocusElement = this._GetReadonlyFocusElement();\n          if (readonlyFocusElement) {\n            return readonlyFocusElement;\n          }\n        }\n        // We need :disabled here so that we don't try to focus on an element that isn't focusable.\n        // :focusable doesn't work because this is called before the custom element is fully upgraded\n        // and is still hidden in the DOM.\n        return this._GetContentElement().not(':disabled').first()[0];\n      },\n      /**\n       * oj-checkboxset doesn't use .oj-text-field-readonly for the focusable readonly content,\n       * so we need to use a different selector.\n       * @memberof oj.ojCheckboxset\n       * @instance\n       * @override\n       * @protected\n       * @return {Element|null}\n       */\n      _GetReadonlyFocusElement: function () {\n        return this.widget()[0].querySelector('.oj-form-control-container');\n      },\n      /**\n       * Sets the disabled option onto the dom.\n       * This is a no-op for checkboxset since its root dom element is a div, and disabled is\n       * invalid on a div. If we did try to set disabled on the div, then restore attributes doesn't\n       * work correctly since it wasn't saved correctly.\n       * @param {Object} node - dom node\n       *\n       * @memberof oj.ojCheckboxset\n       * @instance\n       * @protected\n       * @since 1.0.0\n       */\n      _SetDisabledDom: function () {\n        // no-op\n      },\n      /**\n       * Whether the component is required.\n       *\n       * @return {boolean} true if required; false\n       *\n       * @memberof oj.ojCheckboxset\n       * @instance\n       * @protected\n       * @override\n       */\n      _IsRequired: function () {\n        return this.options.required;\n      },\n      /**\n       * @memberof oj.ojCheckboxset\n       * @instance\n       * @private\n       */\n      _refreshRequired: ojeditablevalue.EditableValueUtils._refreshRequired,\n\n      /**\n       * This function processes the oj-option children, sets the custom renderer, and\n       * creates input type=checkbox and label dom from them.\n       *\n       * We don't want to rely on the framework calling the customOptionRenderer\n       * as a result of setting options[i][\"customOptionRenderer\"] = renderer; in this function.\n       * This could lead to timing bugs when data-oj-binding-provider=\"none\". (when not \"none\",\n       * we know the oj-options are created before the oj-checkboxset gets created, so no timing issue)\n       * Therefore we create the input/label not in the customOptionRenderer,\n       * but in a separate function that we call.\n       * @private\n       * @instance\n       */\n      _processOjOptions: function () {\n        // if the value doesn't exist as an option, it will end up at the top of the resultant array\n        function sortValuesInOptionsOrder(vals, opts) {\n          var values = vals.slice(0);\n          var optIndex = opts.length - 1;\n          var valIndex = values.length - 1;\n          while (valIndex > 0 && optIndex > -1) {\n            var optVal = opts[optIndex].value;\n            var val = values[valIndex];\n            if (optVal !== val) {\n              var i = values.indexOf(optVal);\n              if (i > -1) {\n                values[i] = val;\n                values[valIndex] = optVal;\n                valIndex -= 1;\n              }\n              optIndex -= 1;\n            } else {\n              valIndex -= 1;\n              optIndex -= 1;\n            }\n          }\n          return values;\n        }\n\n        // set the custom renderer on oj-option\n        if (this._IsCustomElement()) {\n          var i;\n          var len;\n          var domElem = this.element[0];\n          var wrapperDom = domElem.querySelector('.oj-checkboxset-wrapper');\n          var renderer = this._customOptionRenderer.bind(this);\n          // Get all the oj-option elements of the oj-checkboxset\n          // Those that are direct child as well as those inside the wrapperDOM\n          var options = this.element\n            .children('oj-option')\n            .add(this.element.children('.oj-checkboxset-wrapper').find('oj-option'));\n          var selectedOptionsArray = sortValuesInOptionsOrder(this.options.value, options);\n          var numSelected = selectedOptionsArray.length;\n\n          // If the wrapperDom isn't created yet, we use the component element as the wrapper\n          if (!wrapperDom) {\n            wrapperDom = domElem;\n          }\n\n          var novaluespan = domElem.querySelector('[data-no-value-span]');\n          // Remove the old no-value span when there is one and there is a current selection or not in readonly mode\n          if (novaluespan) {\n            if (numSelected > 0 || !this.options.readOnly) {\n              novaluespan.parentElement.removeChild(novaluespan);\n            }\n          } else if (numSelected === 0 && this.options.readOnly) {\n            // Otherwise, add the no value span if no selection.\n            var span = document.createElement('span');\n            span.setAttribute('data-no-value-span', '');\n            span.setAttribute('class', 'oj-choice-item');\n            span.setAttribute('aria-readonly', true);\n            var noCheckboxSelected = this.getTranslatedString('readonlyNoValue');\n            if (noCheckboxSelected !== null) {\n              span.textContent = noCheckboxSelected;\n            }\n            wrapperDom.appendChild(span); // @HTMLUpdateOK\n          }\n\n          for (i = 0, len = options.length; i < len; i++) {\n            options[i].customOptionRenderer = renderer;\n            if (this.options.readOnly) {\n              this._processReadonlyOptions(options[i], selectedOptionsArray);\n            } else {\n              this._initInputLabelFromOjOption(options[i]);\n            }\n          }\n        }\n      },\n\n      /**\n       * @memberof oj.ojCheckboxset\n       * @instance\n       * @private\n       */\n      _processReadonlyOptions: function (ojOption, selectedOptionsArray) {\n        const optionValue = ojOption.value;\n        const selectedArrayLength = selectedOptionsArray.length;\n        const element = this.element.get(0);\n        const choiceItemSelector = 'span.oj-choice-item';\n        const parentSpan = $(ojOption).parentsUntil(element, choiceItemSelector).get(0);\n\n        // If the provided ojOption is present inside an oj-choice-item, it means\n        // it is already processed. If not, it is still not processed.\n        // It should be sufficient to hide just ojOption element when it is not\n        // processed. But, if it is processed, then we need to hide the parent\n        // oj-choice-item\n        if (parentSpan == null) {\n          // this is when span wrapper is not yet created around ojoption.\n          // the ojoption will be hidden first and then unhide the checked option\n          ojOption.classList.add('oj-helper-hidden');\n        } else {\n          parentSpan.classList.add('oj-helper-hidden');\n        }\n        // if element is readonly and there is no checked option then we do not need to process options,\n        if (selectedArrayLength > 0) {\n          var i = selectedOptionsArray.indexOf(optionValue);\n          if (i > -1) {\n            var isLastOption = i === selectedArrayLength - 1;\n            this._initReadonlyLabelFromOjOption(ojOption, parentSpan, isLastOption);\n          } else if (parentSpan != null) {\n            // remove 'aria-readonly' for unselected options.\n            parentSpan.removeAttribute('aria-readonly');\n          }\n        } else if (parentSpan != null) {\n          // remove 'aria-readonly' for all options when set value to empty\n          parentSpan.removeAttribute('aria-readonly');\n        }\n      },\n      /**\n       * Create the input type='checkbox'/label dom from attributes on oj-option element.\n       * oj-checkboxset is made up of input/labels.\n       * This gets called during the oj-checkboxset _CreateComponent and refresh\n       * @param {Element} elem the oj-option element\n       * @private\n       * @instance\n       */\n      _initInputLabelFromOjOption: function (elem) {\n        var span;\n        var label;\n        var ojoption = elem;\n\n        // let's make sure that each oj-option has an ID so the\n        // label element can reference the input element via the 'for' attribute\n        // we have tests in place where oj-option doesn't have id and where it does\n        // both for the databound case and non-databound case. In the databound case, the\n        // bindings are resolved before we get here, so we will be fine.\n        $(ojoption).uniqueId();\n\n        var id = ojoption.getAttribute('id');\n        var checkboxId = id + '|cb';\n        var checkbox = document.getElementById(checkboxId);\n        var alreadyProcessed = checkbox !== null; // Was the oj-option already processed\n\n        // if the oj-option is already processed, we don't need to add the additional dom\n        // in the code below, we use setAttribute() for everything as we want to be\n        // setting the initial value for these elements.\n        if (!alreadyProcessed) {\n          checkbox = document.createElement('input');\n          checkbox.setAttribute('type', 'checkbox');\n          // The value is needed for accessibiliy of the image used for the checkbox\n          checkbox.setAttribute('value', ojoption.value);\n          checkbox.setAttribute('id', checkboxId);\n          // Need to transfer the tabindex to the input element\n          // All the input element will have the same tabindex\n          checkbox.setAttribute('tabindex', this._externalTabIndex);\n          // in readonly mode, if a option is selected, the <oj-option> will be surrounded by <label> tag\n          // if a option is selected, we can set attribute for the previous label and there is no need to create a new label\n          // if a option is not selected, we need to create a new label.\n          if (ojoption.parentElement.nodeName === 'LABEL') {\n            label = ojoption.parentElement;\n            label.parentElement.insertBefore(checkbox, label);\n            // remove 'aria-readonly' when toggle readonly to false\n            label.parentElement.removeAttribute('aria-readonly');\n            // also we need to remove the oj-helper-hidden class from the parentElement\n            label.parentElement.classList.remove('oj-helper-hidden');\n          } else {\n            span = document.createElement('span');\n            label = document.createElement('label');\n            span.setAttribute('class', 'oj-choice-item');\n            ojoption.parentElement.insertBefore(span, ojoption);\n            span.appendChild(checkbox);\n            span.appendChild(label);\n            label.appendChild(ojoption);\n          }\n          label.setAttribute('for', checkboxId);\n\n          // if the ojoption doesn't have any textContent, hide the label element.  The use case for\n          // this is the case where you have an oj-checkboxset with one checkbox with no label (i.e. you\n          // specify one oj-option with no textContent).  We want to hide the generated label element so\n          // that the checkbox is easier to center in the parent container (such as a table cell).\n          // Note: this is not an issue for oj-radioset, as there is no use case that uses a single\n          // radio button in an oj-radioset.\n          if (!ojoption.textContent || ojoption.textContent === '') {\n            label.classList.add('oj-helper-hidden');\n          }\n          // in readonly mode, options are not selected will be hidden\n          // when we toggle readonly to false, we need to remove the 'oj-helper-hidden' class\n          ojoption.classList.remove('oj-helper-hidden');\n        } else {\n          // find the parent label element.  This is the element we need to hide if there is no text\n          // content in the oj-option\n          label = ojoption;\n\n          do {\n            label = label.parentElement;\n          } while (label && !(label.tagName === 'LABEL'));\n\n          // if the ojoption doesn't have any textContent, hide the label element by adding the\n          // class oj-helper-hidden\n          // if for some reason, a label element is not found, don't do anything\n          if (label) {\n            if (!ojoption.textContent || ojoption.textContent === '') {\n              label.classList.add('oj-helper-hidden');\n            } else {\n              label.classList.remove('oj-helper-hidden');\n            }\n          }\n          // if the element is already processed we need to check if the component has readonly classes, then we need to clear the\n          // classes when it is not readonly\n          if (!this.options.readOnly) {\n            var parentSpan = ojoption;\n            do {\n              parentSpan = parentSpan.parentElement;\n            } while (parentSpan && !parentSpan.classList.contains('oj-choice-item'));\n            if (\n              parentSpan &&\n              parentSpan.classList.contains('oj-helper-hidden') &&\n              parentSpan.classList.contains('oj-choice-item') &&\n              parentSpan.tagName === 'SPAN'\n            ) {\n              parentSpan.classList.remove('oj-helper-hidden');\n            }\n            if (ojoption && ojoption.classList.contains('oj-helper-hidden')) {\n              ojoption.classList.remove('oj-helper-hidden');\n            }\n            if (checkbox && checkbox.parentElement.classList.contains('oj-helper-hidden')) {\n              checkbox.parentElement.classList.remove('oj-helper-hidden');\n            }\n          }\n        }\n\n        var name = this.element[0].id; // Use the id of the ojcheckboxset as the name of the oj-options.\n        var ariaLabel = ojoption.getAttribute('aria-label');\n        var ariaLabelledBy = ojoption.getAttribute('aria-labelledby');\n\n        var separatorNode = label.querySelector('span[data-oj-internal]');\n        if (separatorNode) {\n          separatorNode.parentElement.removeChild(separatorNode);\n        }\n\n        // The value attribute of the checkbox only supports text, so we need to be\n        // able to access the oj-option's value property instead.  This attribute\n        // is a link back to the oj-option so that we don't need to use dom traversal\n        // to get to the oj-option to get its value.\n        checkbox.setAttribute('data-oj-option-id', id);\n\n        if (name && name !== '') {\n          checkbox.setAttribute('name', name);\n        } else {\n          checkbox.removeAttribute('name');\n        }\n\n        if (ariaLabel && ariaLabel !== '') {\n          checkbox.setAttribute('aria-label', ariaLabel);\n        } else {\n          checkbox.removeAttribute('aria-label');\n        }\n        if (ariaLabelledBy && ariaLabelledBy !== '') {\n          checkbox.setAttribute('aria-labelledby', ariaLabelledBy);\n        } else {\n          checkbox.removeAttribute('aria-labelledby');\n        }\n        if (ojoption.disabled) {\n          checkbox.setAttribute('disabled', true);\n        } else {\n          checkbox.removeAttribute('disabled');\n        }\n      },\n      /**\n       * @memberof oj.ojCheckboxset\n       * @instance\n       * @private\n       */\n      _initReadonlyLabelFromOjOption: function (elem, parentSpan, isLastOption) {\n        function toggleLabelSeparator(label, needsSeparator) {\n          var separatorNode = label.querySelector('span[data-oj-internal]');\n          if (needsSeparator && !separatorNode) {\n            var separator = Translations.getTranslatedString('oj-converter.plural-separator');\n            separatorNode = document.createElement('span');\n            separatorNode.setAttribute('data-oj-internal', '');\n            separatorNode.textContent = separator;\n            label.appendChild(separatorNode);\n          } else if (!needsSeparator && separatorNode) {\n            separatorNode.parentElement.removeChild(separatorNode);\n          }\n        }\n\n        var label = document.createElement('label');\n        var ojoption = elem;\n        var isRowDirection = this.element.hasClass('oj-choice-direction-row');\n        var needsSeparator = isRowDirection && !isLastOption;\n        if (parentSpan) {\n          $(ojoption).uniqueId();\n\n          var id = ojoption.getAttribute('id');\n          var checkboxId = id + '|cb';\n          var checkbox = document.getElementById(checkboxId);\n          var checkboxExists = checkbox !== null;\n          // we do not render the input when the checkboxset id readonly\n          // the checkboxset only exists in the update case where readonly is set using setAttribute\n          // so we would need to hide the input as we only show label in case of readonly and not input.\n          if (checkboxExists) {\n            checkbox.parentElement.classList.add('oj-helper-hidden');\n            // when we toggle readonly to true, we need to remove the checkbox element.\n            var oldlabel = checkbox.parentElement.nextElementSibling;\n            if (oldlabel !== null) {\n              label.appendChild(ojoption);\n              // Before removing the checkbox element, check if _ojRadioCheckbox is initialized\n              // for the option. If so, destroy the wiget before removing it from the DOM\n              if (checkbox.classList.contains('oj-checkbox')) {\n                $(checkbox)._ojRadioCheckbox('destroy');\n              }\n              parentSpan.removeChild(oldlabel.previousSibling);\n              parentSpan.removeChild(oldlabel);\n              parentSpan.appendChild(label);\n            }\n          }\n          parentSpan.classList.remove('oj-helper-hidden');\n          parentSpan.setAttribute('aria-readonly', true);\n          toggleLabelSeparator(ojoption.parentElement, needsSeparator);\n        } else {\n          elem.classList.remove('oj-helper-hidden');\n          var span = document.createElement('span');\n          ojoption.parentElement.insertBefore(span, ojoption); // @HTMLUpdateOK\n          span.setAttribute('class', 'oj-choice-item');\n          label.appendChild(ojoption);\n          toggleLabelSeparator(label, needsSeparator);\n          if (!isRowDirection) {\n            label.setAttribute('class', 'oj-checkbox-label');\n          }\n          span.appendChild(label);\n          span.setAttribute('aria-readonly', true);\n        }\n      },\n\n      // custom oj-option renderer\n      // Because we can't rely on this being called when we set the customOptionRenderer property\n      // in _processOjOptions we shouldn't do the input.label creation from the oj-option\n      // in this function. (If we did, the _ComponentCreate code that relies on the\n      // inputs/labels being created already would not work.)\n      // The correct thing to do is to create the input/label in _initInputLabelFromOjOption\n      // Then rely on this function being called after the oj-option has been created and we are\n      // changing properties on it.\n      _customOptionRenderer: function (elem) {\n        var ojoption = elem;\n        var id = ojoption.getAttribute('id');\n        var checkboxId = id + '|cb';\n        var checkbox = document.getElementById(checkboxId);\n        // Was the oj-option already rendered into an _ojRadioCheckbox() in _CreateComponent?\n        var checkboxExists = checkbox !== null;\n        var hasOjCheckboxClass = checkboxExists && checkbox.classList.contains('oj-checkbox');\n\n        // When an oj-option child is disabled (by setting the disabled attribute to\n        // true) and it re-renders, the component should refresh automatically rather than requiring the\n        // user to call refresh. See .\n        if (hasOjCheckboxClass) {\n          $(checkbox)._ojRadioCheckbox('option', 'disabled', ojoption.disabled);\n        }\n      },\n      /**\n       * If custom element, get the labelledBy option, and set this\n       * onto the root dom element as aria-labelledby. We append \"|label\" so it matches the id that\n       * is on the oj-label's label element.\n       * @memberof oj.ojCheckboxset\n       * @instance\n       * @private\n       */\n      _labelledByUpdatedForSet: LabeledByUtils._labelledByUpdatedForSet,\n\n      /**\n       * Returns a jquery object that is a set of elements that are input type checkbox\n       * and have the name of the first checkbox found.\n       *\n       * @return {jQuery} jquery object of all the checkboxes within the root dom element\n       * that have the same 'name' attribute as the first checkbox found.\n       * @private\n       * @memberof oj.ojCheckboxset\n       */\n      _findCheckboxesWithMatchingName: function () {\n        var allcheckboxes;\n        var $first = this.element.find('input[type=checkbox]:first');\n        var name;\n        var selector;\n\n        if ($first.length === 0) {\n          Logger.warn('Could not find any input type=checkbox within this element');\n        }\n        // get the name attribute of the first input checkbox\n        name = $first.attr('name');\n        // find all input checkboxes with matching name\n        if (name === undefined) {\n          // search for all checkboxes with no name\n          allcheckboxes = this.element.find('input[type=checkbox]');\n          // now loop and find the ones without 'name' attribute\n          return allcheckboxes.not('[name]');\n        }\n\n        // search for all checkboxes with the name\n        selector = 'input[type=checkbox][name=\"' + name + '\"]';\n        return this.element.find(selector);\n      },\n\n      // Override to set custom launcher\n      _NotifyContextMenuGesture: function (menu, event, eventType) {\n        // Setting the launcher to the first tabbable checkbox in the set.\n        // Component owner should feel free to specify a different launcher if appropriate,\n        // e.g. could specify the \"current\" checkbox rather than the first if desired.\n        // See the superclass JSDoc for _OpenContextMenu for tips on choosing a launcher.\n        var launcher = this.element.find('input[type=checkbox]:tabbable').first();\n        this._OpenContextMenu(event, eventType, { launcher: launcher });\n      },\n      // Override to set launcher to widget\n      _GetMessagingLauncherElement: function () {\n        // focus events only get triggered on input, but they do bubble up and we will capture them\n        // on the widget.\n        // mouseenter events get called once once if the user hovers over for the entire widget. if\n        // we put it on the inputs, it gets called every time you leave and enter a new input. Plus,\n        // this doesn't work when we hide the input like we do in the native themes.\n        return this.widget();\n      },\n      /**\n       * _setup is called on create and refresh. Use the disabled option to\n       * update the component. If the component's option is disabled, then\n       * leave it alone.\n       * @memberof oj.ojCheckboxset\n       * @instance\n       * @private\n       */\n      _setup: function () {\n        // at this point we already have this.$checkboxes set to a list of checkboxes for this\n        // checkboxset\n        this._propagateDisabled(this.options.disabled);\n\n        if (this.$checkboxes !== null) {\n          if (this.$checkboxes.length === 1) {\n            this.element.addClass('oj-checkboxset-single');\n          } else {\n            this.element.removeClass('oj-checkboxset-single');\n          }\n        }\n\n        // add to the root dom the style class 'oj-read-only'\n        if (this.options.readOnly) {\n          this.element.addClass('oj-read-only');\n        } else {\n          this.element.removeClass('oj-read-only');\n        }\n\n        // add to the root dom the style class 'oj-choice-direction-column'\n        // if there isn't already a 'oj-choice-direction-row' or 'oj-choice-direction-column' there.\n        if (\n          !this.element.hasClass('oj-choice-direction-column') &&\n          !this.element.hasClass('oj-choice-direction-row')\n        ) {\n          this.element.addClass('oj-choice-direction-column');\n        }\n        this._refreshRequired(this.options.required);\n        var widget = this.widget();\n        this._labelledByUpdatedForSet(widget[0].id, null, this.options.labelledBy, widget);\n      },\n      _events: {\n        change: function (event) {\n          this._HandleChangeEvent(event);\n        },\n        'click .oj-choice-item': function (event) {\n          if (\n            !this.widget()[0].classList.contains('oj-choice-direction-row') &&\n            event.target.tagName !== 'INPUT'\n          ) {\n            $(event.target).find('input').click();\n          }\n        }\n      },\n      /**\n       * If value is undefined or null, set it to the default value, which is [].\n       * Else, confirm it is an Array and throw an error if it isn't.\n       * @memberof oj.ojCheckboxset\n       * @instance\n       * @private\n       * @param {Object|null|undefined} value the value to check\n       * @throws new Error if value (undefined is converted to an []) isn't an Array\n       */\n      _checkValueType: function (value) {\n        // if value is undefined or null, set it to its default value [].\n        if (value == null) {\n          this.option('value', [], { _context: { writeback: true, internalSet: true } });\n        } else {\n          this._confirmValueIsArray(value);\n        }\n      },\n      /**\n       * Confirm value is an Array.\n       * @memberof oj.ojCheckboxset\n       * @instance\n       * @private\n       * @param {Object|null|undefined} value the value to check\n       * @throws new Error if value isn't an Array\n       */\n      _confirmValueIsArray: function (value) {\n        if (!Array.isArray(value)) {\n          throw new Error(\n            \"Invalid 'value' set on JET Checkboxset: \" + value + '.It must be an Array. '\n          );\n        }\n      },\n\n      /**\n       * @param {Event} event DOM event\n       * @override\n       * @protected\n       * @memberof oj.ojCheckboxset\n       */\n      _HandleChangeEvent: function (event) {\n        var submittedValue;\n        var checkboxes;\n\n        // keep oj-selected in sync with the input element's checked state\n        checkboxes = this.$checkboxes;\n        if (checkboxes.length > 0) {\n          checkboxes.each(function () {\n            if (this === event.target) {\n              // the target is one of the checkboxes. Update the oj-selected class to keep it\n              // in sync with the input's HTML checked attribute\n              $(this)._ojRadioCheckbox('setSelectedClass', event.target.checked);\n            }\n          });\n        }\n        // run full validation. There is no need to check if values have changed\n        // since for checkboxset/radioset if we get into this function we know value has changed.\n        // passing in doValueChangeCheck: false will skip the new-old value comparison\n        submittedValue = this._GetDisplayValue();\n        this._SetValue(submittedValue, event, _sValueChangeCheckFalse);\n      },\n\n      /**\n       * Returns the display value that is ready to be passed to the converter.\n       *\n       * @param {Object} value the stored value if available that needs to be formatted for display\n       * @override\n       * @protected\n       * @memberof oj.ojCheckboxset\n       */\n      _GetDisplayValue: function (\n        // eslint-disable-next-line no-unused-vars\n        value\n      ) {\n        // return the value of the 'checked' checkboxes\n        return this._GetElementValue();\n      },\n      /**\n       * Called when the display value on the element needs to be updated\n       * as a result of a value change.\n       * ojCheckboxset stores an Array value, and this value matches the values\n       * of the currently checked checkboxes. So, if we need to set the display value,\n       * what this means is we need to 'check' the checkboxes whose values match the\n       * displayValue and 'uncheck' those that don't.\n       *\n       * @param {Array} displayValueArray an Array of values that need to be checked, e.g., [\"red\",\"blue\"].\n       *  Any checkbox in the checkboxset that doesn't match one of the checkBoxes needs to be unchecked\n       *  if it isn't already.\n       * @override\n       * @protected\n       * @throws new Error if displayValueArray is not an Array\n       * @memberof oj.ojCheckboxset\n       */\n      _SetDisplayValue: function (displayValueArray) {\n        var i;\n        var length = this.$checkboxes.length;\n        var optionValue;\n        var checkbox;\n        var $checkbox;\n\n        this._checkValueType(displayValueArray);\n\n        // If it is empty or not an array, then set all the _ojRadioCheckboxes's checked option to false.\n        // _GetDisplayValue gets the checked options and creates an Array from it.\n        if (\n          displayValueArray === null ||\n          displayValueArray === undefined ||\n          displayValueArray.length === 0\n        ) {\n          this.$checkboxes._ojRadioCheckbox('option', 'checked', false);\n        } else {\n          // go through each _ojRadioCheckbox and see if it needs to be checked or unchecked.\n          for (i = 0; i < length; i++) {\n            checkbox = this.$checkboxes[i];\n            $checkbox = $(checkbox);\n            optionValue = this._GetOptionValue(checkbox);\n            // does the checkbox's value exist in the checkedBoxes array?\n            var index = this._GetOptionIndex(displayValueArray, optionValue);\n            var checked = $checkbox._ojRadioCheckbox('option', 'checked');\n\n            if (index !== -1) {\n              // yes. this needs to be checked, if it isn't already\n              if (!checked) {\n                $checkbox._ojRadioCheckbox('option', 'checked', true);\n              }\n            } else if (checked) {\n              // no. this needs to be unchecked, if it isn't already\n              $checkbox._ojRadioCheckbox('option', 'checked', false);\n            }\n          }\n        }\n      },\n      /**\n       * Returns the element's value. Normally, this is a call to this.element.val(),\n       * but in the case of ojCheckboxset, the element's value is really the value\n       * of the checked checkboxes in the set.\n       * @override\n       * @protected\n       * @memberof oj.ojCheckboxset\n       * @return {Array} An Array<any> of selected values or the empty array [] if nothing selected.\n       */\n      _GetElementValue: function () {\n        // \"input:checked\" selects checkboxes that are currently checked as\n        // reflected in their boolean (true or false) checked property,\n        // which is affected when the user clicks the checkbox for example.\n        // for checkboxset, there will be zero or more checked;\n        var self = this;\n        var checkedValues = [];\n        var selectedCheckboxes = this.$checkboxes.filter(':checked');\n\n        if (selectedCheckboxes.length === 0) {\n          return [];\n        }\n\n        selectedCheckboxes.each(function () {\n          checkedValues.push(self._GetOptionValue(this));\n        });\n        return checkedValues;\n      },\n\n      /**\n       * Returns the index of the array that matches the optionValue. First check\n       * equality with ===, then if not found, check with deep compare,\n       * oj.Object.compareValues(), because values can be objects or arrays.\n       * @override\n       * @protected\n       * @memberof oj.ojCheckboxset\n       */\n      _GetOptionIndex: function (optionValueArray, optionValue) {\n        // Find the matching value via === comparison that indexOf uses\n        var matchIndex = optionValueArray.indexOf(optionValue);\n        var length;\n\n        // If not found via indexOf(), do a deep equals compare\n        if (matchIndex === -1) {\n          length = optionValueArray.length;\n          for (var i = 0; i < length; i++) {\n            if (oj.Object.compareValues(optionValueArray[i], optionValue)) {\n              matchIndex = i;\n              break;\n            }\n          }\n        }\n\n        return matchIndex;\n      },\n      /**\n       * For custom element, we get the value from the oj-option element, otherwise\n       * we get the value from the checkbox element.\n       * @override\n       * @protected\n       * @memberof oj.ojCheckboxset\n       * @return {any} Returns the value property of the associated oj-option, or the value attribute of the checkbox element.\n       */\n      _GetOptionValue: function (checkboxElem) {\n        var option;\n        var val;\n\n        if (this._IsCustomElement()) {\n          option = document.getElementById(checkboxElem.getAttribute('data-oj-option-id'));\n\n          if (option) {\n            val = option.value;\n          }\n        } else {\n          val = checkboxElem.value;\n        }\n\n        return val;\n      },\n\n      /**\n       * Returns the default styleclass for the component. Currently this is\n       * used to pass to the ojLabel component, which will append -label and\n       * add the style class onto the label. This way we can style the label\n       * specific to the input component. For example, for inline labels, the\n       * checkboxset/checkboxset components need to have margin-top:0, whereas all the\n       * other inputs need it to be .5em. So we'll have a special margin-top style\n       * for .oj-label-inline.oj-checkboxset-label\n       * All input components must override\n       *\n       * @return {string}\n       * @memberof oj.ojCheckboxset\n       * @override\n       * @protected\n       */\n      _GetDefaultStyleClass: function () {\n        return 'oj-checkboxset';\n      },\n      /**\n       * Returns a jquery object of the elements representing the content nodes (checkboxes/labels).\n       * @protected\n       * @override\n       * @memberof oj.ojCheckboxset\n       */\n      _GetContentElement: function () {\n        if (this.$checkboxes != null) {\n          return this.$checkboxes;\n        }\n\n        this.$checkboxes = this._findCheckboxesWithMatchingName();\n        return this.$checkboxes;\n      },\n\n      /**\n       * Called to find out if aria-required is unsupported. This is needed for the label.\n       * It is not legal to have aria-required on radio/checkboxes, nor on\n       * radiogroup/group.\n       * If aria-required is not supported, then we wrap the required icon as well as the\n       * help icons so that JAWS can read required. We don't do this for form controls that use\n       * aria-required because if we did JAWS would read required twice.\n       * @memberof oj.ojCheckboxset\n       * @instance\n       * @protected\n       * @return {boolean}\n       */\n      _AriaRequiredUnsupported: function () {\n        return true;\n      },\n\n      /**\n       * This is called from InlineHelpHintsStrategy to determine\n       * the location of the inline help hints, above the component\n       * or below.\n       * @ignore\n       * @protected\n       * @override\n       * @memberof oj.ojCheckboxset\n       * @return {'above'|'inline'}\n       */\n      _ShowHelpHintsLocation: function () {\n        return 'above';\n      },\n\n      /**\n       * Performs post processing after required option is set by taking the following steps.\n       *\n       * - if component is invalid and has messgesShown -> required: false/true -> clear component errors;\n       * run full validation with UI value (we don't know if the UI error is from a required validator\n       * or something else);<br/>\n       * &nbsp;&nbsp;- if there are validation errors, then value not pushed to model; messagesShown is\n       * updated<br/>\n       * &nbsp;&nbsp;- if no errors result from the validation, push value to model; author needs to\n       * listen to optionChange(value) to clear custom errors.<br/>\n       *\n       * - if component is invalid and has messagesHidden -> required: false -> clear component\n       * errors; no deferred validation is run.<br/>\n       * - if component has no error -> required: true -> run deferred validation (we don't want to flag\n       * errors unnecessarily)<br/>\n       * - messagesCustom is never cleared<br/>\n       *\n       * @param {string} option\n       *\n       * @memberof oj.ojCheckboxset\n       * @instance\n       * @protected\n       */\n      _AfterSetOptionRequired: ojeditablevalue.EditableValueUtils._AfterSetOptionRequired,\n\n      /**\n       *\n       * @param {boolean} _disabled\n       * @private\n       * @memberof oj.ojCheckboxset\n       */\n      _propagateDisabled: function (_disabled) {\n        var disabled = !!_disabled;\n        this.$checkboxes.each(function () {\n          // this is the technique to use to call package-private functions\n          // Calling it like this.$radios.ojRadioCheckbox(\"__setAncestorComponentDisabled\",value)\n          // gives an error because jquery prevents you from calling functions with an \"_\"\n          //\n          // This is how we handle 'disabled' for the checkboxset. We don't change the radiocheckbox\n          // component's disabled option ever since if we do that we've lost what the initial disabled\n          // state is (we store the disabled dom value from the radio into its disabled option)\n          // and we need that when we refresh. Instead what we do\n          // is we mark if its ancestor (the checkboxset) is disabled or not. Then, when we render\n          // out the checkboxes 'disabled' state, like oj-disabled, we look to see if it is 'effectively\n          // disabled' (see _IsEffectivelyDisabled call in ojRadioCheckbox), that is if its\n          // option is disabled OR its ancestor (the checkboxset) is disabled.\n          $(this).data('oj-_ojRadioCheckbox').__setAncestorComponentDisabled(disabled);\n        });\n\n        this.$checkboxes._ojRadioCheckbox('refreshDisabled'); // re-render disabled\n      },\n\n      /**\n       * Updates the component's state based on whether or not it is in the readonly\n       * state.\n       * @private\n       * @memberof! oj.ojCheckboxSet\n       */\n      _updateReadonlyState: function () {\n        const wrapperDom = this.element[0].querySelector('.oj-checkboxset-wrapper');\n        if (this.options.readOnly) {\n          wrapperDom.setAttribute('tabindex', this._externalTabIndex);\n          this.element.addClass('oj-read-only');\n\n          // JET-49297 - reassess accessibility implementation of 'readonly' checkboxset\n          // In readonly mode, we will not have any checkbox input in the visible DOM. Thus,\n          // in this state it will just be showing generic text based on the value selected.\n          // So, we need to clean up the role along with the aria-labelledby attributes we added\n          // for that role to make things accessible.\n          this.element.removeAttr('role').removeAttr('aria-labelledby');\n          return;\n        }\n\n        // remove tabindex and role\n        wrapperDom.removeAttribute('tabindex');\n        this.element.removeClass('oj-read-only');\n\n        // JET-49297 - reassess accessibility implementation of 'readonly' checkboxset\n        // add back the role and aria attributes removed before\n        this.element.attr('role', 'group');\n        this._labelledByUpdatedForSet(\n          this.widget()[0].id,\n          null,\n          this.options.labelledBy,\n          this.widget()\n        );\n      },\n\n      /**\n       * @override\n       * @private\n       * @memberof oj.ojCheckboxset\n       */\n      _setOption: function (key, value, flags) {\n        var originalValue = this.options.labelledBy;\n        this._super(key, value, flags);\n\n        switch (key) {\n          case 'disabled':\n            this._propagateDisabled(value);\n            break;\n          case 'readOnly':\n            this.options.readOnly = !!value;\n            var val = this.options.value;\n            this._updateReadonlyState();\n            this._ResetComponentState();\n            // when toggle readonly to false, we need to check the initial set values.\n            if (val != null) {\n              this._SetDisplayValue(val);\n            }\n            break;\n          case 'value':\n            this._processOjOptions();\n            break;\n          case 'labelledBy':\n            // remove the old one and add the new one\n            var widget = this.widget();\n            this._labelledByUpdatedForSet(widget[0].id, originalValue, value, widget);\n            break;\n          case 'options':\n            oj.RadioCheckboxUtils.generateOptionsFromData.call(this);\n            break;\n          case 'optionsKeys':\n          case 'optionRenderer':\n            oj.RadioCheckboxUtils.renderOptions.call(this);\n            break;\n          default:\n            break;\n        }\n      },\n\n      /**\n       * Performs post processing after _SetOption() is called. Different options when changed perform\n       * different tasks. See _AfterSetOption[OptionName] method for details.\n       *\n       * @param {string} option\n       * @param {Object|string=} previous\n       * @param {Object=} flags\n       * @protected\n       * @memberof oj.ojCheckboxset\n       * @instance\n       * @override\n       */\n      // eslint-disable-next-line no-unused-vars\n      _AfterSetOption: function (option, previous, flags) {\n        this._superApply(arguments);\n        switch (option) {\n          case 'required':\n            this._AfterSetOptionRequired(option);\n            break;\n          default:\n            break;\n        }\n      },\n\n      getNodeBySubId: function (locator) {\n        var node = this._super(locator);\n        var checkboxes;\n        var subId;\n        var value;\n\n        if (!node) {\n          checkboxes = this.$checkboxes.get();\n          subId = locator.subId;\n\n          switch (subId) {\n            case 'oj-checkboxset-inputs': // TODO: deprecated for a while now, remove this in 4.0.0\n              node = checkboxes;\n              break;\n\n            case 'oj-checkboxset-checkbox':\n              // We find these by the value attribute on the input element, which is\n              // much more stable that using an index.\n              value = locator.value;\n\n              if (typeof value !== 'undefined') {\n                var arrayLength = checkboxes.length;\n                var i;\n                var matchIndex = -1;\n                var checkboxValues = [];\n\n                // Build the values array\n                for (i = 0; i < arrayLength; i++) {\n                  checkboxValues[i] = this._GetOptionValue(checkboxes[i]);\n                }\n\n                // Find the index of the matching value.\n                matchIndex = this._GetOptionIndex(checkboxValues, value);\n\n                if (matchIndex !== -1) {\n                  node = checkboxes[matchIndex];\n                }\n              }\n              break;\n            default:\n              break;\n          }\n        }\n        // Non-null locators have to be handled by the component subclasses\n        return node || null;\n      },\n\n      getSubIdByNode: function (node) {\n        var topElem = this._GetContentElement()[0].parentElement.parentElement.parentElement;\n        var currentNode = node;\n\n        while (currentNode && currentNode !== topElem) {\n          if (currentNode.nodeName === 'LABEL') {\n            currentNode = document.getElementById(currentNode.for);\n          }\n\n          if (currentNode.nodeName === 'INPUT') {\n            return { subId: 'oj-checkboxset-checkbox', value: this._GetOptionValue(currentNode) };\n          }\n\n          currentNode = currentNode.parentElement;\n        }\n\n        return this._super(node);\n      },\n\n      /**\n       * @ignore\n       * @protected\n       * @memberof oj.ojCheckboxset\n       * @override\n       */\n      _destroy: function () {\n        var ret = this._super();\n        var wrapperDom = this.element[0].firstElementChild;\n\n        if (this.$checkboxes) {\n          this.$checkboxes._ojRadioCheckbox('destroy');\n        }\n\n        // remove the dom we added to wrap the children of this.element, but don't remove the children.\n        $(wrapperDom).contents().unwrap();\n\n        oj.RadioCheckboxUtils.removeDataListener.call(this);\n\n        return ret;\n      }\n    });\n  })();\n\n});\n","/**\n * @license\n * Copyright (c) 2014, 2023, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\ndefine(['ojs/ojcore-base', 'jquery', 'ojs/ojlogger', 'ojs/ojcomponentcore'], function (oj, $, Logger, Components) { 'use strict';\n\n  oj = oj && Object.prototype.hasOwnProperty.call(oj, 'default') ? oj['default'] : oj;\n  $ = $ && Object.prototype.hasOwnProperty.call($, 'default') ? $['default'] : $;\n\n  /**\n   * The _ojRadio component enhances a browser input element into one that is\n   * of type=radio. This is a private component used by ojRadioset.\n   *\n   * <h3>Events:</h3>\n   * <ul>\n   *   <li>clicked/checked?<p>\n   *   Triggered if the checkbox is clicked; or if the checkbox was checked programatically\n   *   with the checked option.\n   *   </li>\n   * </ul>\n   *\n   * @ojcomponent oj._ojRadioCheckbox\n   * @private\n   * @augments oj.baseComponent TODO: Should I extend this?\n   * Pros: it gives me oj-disabled/oj-enabled. (easy to add myself)\n   * Cons: It gives me tooltip stuff that I don't want. I want that on the div or on the first checkbox only.\n   * Pro/Con?: it rewrites required for me if it is on the dom node, but then it makes it required??? Should I rewrite required or don't care?\n   */\n  oj.__registerWidget('oj._ojRadioCheckbox', $.oj.baseComponent, {\n    version: '1.0.0',\n    defaultElement: '<input>',\n    widgetEventPrefix: 'oj',\n    options: {\n      /**\n       * First we look for the disabled option to be explicitly set. If not, then\n       * we look if disabled is on the dom. If null, disabled defaults to false.\n       * @expose\n       * @type {?boolean|undefined}\n       * @default <code class=\"prettyprint\">false</code>\n       * @public\n       * @instance\n       * @memberof oj._ojRadioCheckbox\n       */\n      disabled: null,\n      /**\n       * First we look for the checked option to be explicitly set. If not, then\n       * we look if checked is on the dom. If null, checked defaults to false.\n       * @expose\n       * @type {?boolean}\n       * @public\n       * @instance\n       * @memberof oj._ojRadioCheckbox */\n      checked: null,\n      /**\n       * First we look for the disabled option to be explicitly set. If not, then\n       * we look if disabled is on the dom. If null, disabled defaults to false.\n       * @expose\n       * @type {?boolean}\n       * @default <code class=\"prettyprint\">false</code>\n       * @public\n       * @instance\n       * @memberof oj._ojRadioCheckbox\n       */\n      type: null\n    },\n    /** ** start Public APIs ****/\n    /**\n     *\n     * <p>This method does not accept any arguments.\n     *\n     * @public\n     * @expose\n     * @memberof oj.RadioCheckbox\n     * @return {jQuery} the label(s) for the checkbox/radio input\n     */\n    label: function () {\n      if (this.$label === undefined) {\n        this.$label = this._getLabelsForElement();\n      }\n      return this.$label;\n    },\n    /**\n     * @expose\n     * @memberof oj._ojRadioCheckbox\n     * @instance\n     * @override\n     * @example <caption>Invoke the <code class=\"prettyprint\">refresh</code> method:</caption>\n     * $( \".selector\" )._ojRadioCheckbox( \"refresh\" );\n     */\n    refresh: function () {\n      this._super();\n      this._setup();\n    },\n    /**\n     * @expose\n     * @memberof oj._ojRadioCheckbox\n     * @instance\n     * @override\n     * @example <caption>Invoke the <code class=\"prettyprint\">refreshDisabled</code> method:</caption>\n     * $( \".selector\" )._ojRadioCheckbox( \"refreshDisabled\" );\n     */\n    refreshDisabled: function () {\n      // this looks at the effectivelyDisabled flag and updates the disabled attributes on the dom.\n      this._renderDisabled();\n    },\n    /**\n     * Set the oj-selected class to the element's checked property.\n     * We keep the oj-selected class in sync with the input's checked attribute, not necessarily the\n     * component's checked property. The component's checked property is set after it is validated.\n     * if validation doesn't pass, the input may still be checked, but the this.options.checked isn't.\n     * Think of it like an inputText. You can clear it out when it is required, blur,\n     * and the display value is an empty field, but the value is the value that was there before.\n     * @expose\n     * @memberof oj._ojRadioCheckbox\n     * @instance\n     * @override\n     * @example <caption>Invoke the <code class=\"prettyprint\">setSelectedClass</code> method:</caption>\n     * $( \".selector\" )._ojRadioCheckbox( \"setSelectedClass\", true );\n     */\n    setSelectedClass: function (checked) {\n      this.element.toggleClass('oj-selected', checked);\n      this.$label.toggleClass('oj-selected', checked);\n      this.$choiceItem.toggleClass('oj-selected', checked);\n    },\n    /**\n     * Returns a jQuery object containing the element visually representing the checkbox.\n     *\n     * <p>This method does not accept any arguments.\n     *\n     * @expose\n     * @memberof oj._ojRadioCheckbox\n     * @instance\n     * @return {jQuery} the checkbox or radio\n     */\n    widget: function () {\n      return this.uiRadioCheckbox;\n    },\n\n    /** ** end Public APIs ****/\n\n    /** ** start internal widget functions ****/\n    /**\n     * Called at component create time primarily to initialize options, often using DOM values. This\n     * method is called before _ComponentCreate is called, so components that override this method\n     * should be aware that the component has not been rendered yet. The element DOM is available and\n     * can be relied on to retrieve any default values. <p>\n     * @param {!Object} originalDefaults - original default options defined on the widget and its ancestors\n     * @param {?Object} constructorOptions - options passed into the widget constructor\n     *\n     * @memberof oj._ojRadioCheckbox\n     * @instance\n     * @protected\n     */\n    _InitOptions: function (originalDefaults, constructorOptions) {\n      var checkedFromDom;\n      var disabledFromDom;\n\n      this._super(originalDefaults, constructorOptions);\n\n      // CHECKED:\n      // if options.checked is not set, get it from the element\n      // if options.checked is set to a valid value (boolean), set it on the\n      // element to keep the two in sync (we do this in _CreateComponent->_setup)\n      //\n      // use DOM value if not in constructorOptions\n      if (!('checked' in constructorOptions)) {\n        this.initCheckedFromDom = true;\n        checkedFromDom = !!this.element.prop('checked');\n        // writeback not needed since \"not in constructorOptions\" means \"not bound\"\n        this.option('checked', checkedFromDom, { _context: { internalSet: true } });\n      }\n      if (typeof this.options.checked !== 'boolean') {\n        throw new Error('checked option must be a boolean');\n      }\n      // DISABLED:\n      // if options.disabled is not set, get it from the element\n      // if options.disabled is set to a valid value (boolean), set it on the\n      // element to keep the two in sync (we do this in _CreateComponent->_setup)\n      // use DOM value if not in constructorOptions\n      if (!('disabled' in constructorOptions)) {\n        // !! ensures it is a boolean\n        disabledFromDom = !!this.element.prop('disabled');\n        // writeback not needed since \"not in constructorOptions\" means \"not bound\"\n        this.option('disabled', disabledFromDom, { _context: { internalSet: true } });\n      }\n      if (typeof this.options.disabled !== 'boolean') {\n        throw new Error('disabled option must be a boolean');\n      }\n\n      // TYPE:\n      // Gets the type which will be either radio or checkbox.\n      // writeback not needed since \"not in constructorOptions\" means \"not bound\"\n      if (!('type' in constructorOptions)) {\n        this.option('type', this.element.prop('type'), { _context: { internalSet: true } });\n      }\n    },\n    /**\n     * After _ComponentCreate and _AfterCreate,\n     * the widget should be 100% set up. this._super should be called first.\n     * @override\n     * @protected\n     * @instance\n     * @memberof oj._ojRadioCheckbox\n     */\n    _ComponentCreate: function () {\n      this._super();\n\n      var type = this.options.type;\n      if (type === 'checkbox') {\n        this.uiRadioCheckbox = this.element.addClass('oj-checkbox oj-component');\n        this.$label = this._getLabelsForElement();\n        this.$label.addClass('oj-checkbox-label');\n      } else if (type === 'radio') {\n        this.uiRadioCheckbox = this.element.addClass('oj-radio oj-component');\n        this.$label = this._getLabelsForElement();\n        this.$label.addClass('oj-radio-label');\n      }\n\n      // this will not be null since we create a choice item if there isn't one\n      this.$choiceItem = this._getChoiceItem();\n\n      var iElem = document.createElement('span');\n      iElem.setAttribute('class', 'oj-radiocheckbox-icon oj-component-icon');\n      this.element.wrapAll(iElem); // @HTMLUpdateOK iElem constructed locally\n\n      var self = this;\n      this._focusable(this.element);\n\n      this._AddHoverable(this.$choiceItem);\n      this._AddActiveable(this.$choiceItem);\n\n      // the input gets focus on keyboard tabbing. It bubbles up, so in case the\n      // input element is hidden (e.g., in the native themes the input is hidden and an image is\n      // shown instead), we need to set the focus selectors on the oj-choice-item so\n      // we can style the checked image.\n      this._focusable({\n        element: this.$choiceItem,\n        applyHighlight: true\n      });\n\n      this._AddHoverable(this.$label);\n      this._AddActiveable(this.$label);\n\n      // loop through each label to add dom and styles\n      $.each(self.$label, function () {\n        // wrap children in span\n        $(this.childNodes).wrapAll(\"<span class='oj-radiocheckbox-label-text'></span>\"); // @HTMLUpdateOK\n      });\n      this._setup();\n    },\n    /**\n     * <p>Save only the 'class' attribute since that is what\n     * we manipulate. We don't have to save all the attributes.\n     * </p>\n     *\n     * @param {Object} element - jQuery selection to save attributes for\n     * @protected\n     * @memberof oj._ojRadioCheckbox\n     * @instance\n     * @override\n     */\n    _SaveAttributes: function (element) {\n      this._savedClasses = element.attr('class');\n    },\n    /**\n     * <p>Restore what was saved in _SaveAttributes\n     * </p>\n     *\n     * @protected\n     * @memberof oj._ojRadioCheckbox\n     * @instance\n     * @override\n     */\n    _RestoreAttributes: function () {\n      // restore the saved \"class\" attribute. Setting class attr to undefined is a no/op, so\n      // if this._savedClasses is undefined we explicitly remove the 'class' attribute.\n      if (this._savedClasses) {\n        this.element.attr('class', this._savedClasses);\n      } else {\n        this.element.removeAttr('class');\n      }\n    },\n    /* _setup called during creation */\n    _setup: function () {\n      this._renderDisabled();\n\n      if (!this.initCheckedFromDom) {\n        // if we got it from the dom in _InitOptions, there is no need to reset it on the dom in _setup\n        this._setCheckedOnDom(this.options.checked);\n      }\n      if (this.options.checked) {\n        this.setSelectedClass(this.options.checked);\n      }\n    },\n    _setCheckedOnDom: function (checked) {\n      // !! to turn checked into a boolean\n      // eslint-disable-next-line no-param-reassign\n      checked = !!checked;\n\n      this.element.prop('checked', checked);\n    },\n    _renderDisabled: function () {\n      // Determines whether this component is effectively disabled,\n      // i.e. it has its 'disabled' option set to true or\n      // it has been disabled by its ancestor component\n      var effectivelyDisabled = this._IsEffectivelyDisabled();\n      if (effectivelyDisabled) {\n        // set the dom to show DISABLED, but do NOT change the disabled option!\n        //\n        // when a dom element supports disabled, use that, and not aria-disabled.\n        // having both is an error.\n        this.element\n          .prop('disabled', true)\n          .removeAttr('aria-disabled')\n          .removeClass('oj-enabled')\n          .addClass('oj-disabled');\n\n        this.$label.removeClass('oj-enabled').addClass('oj-disabled');\n\n        this.$choiceItem.removeClass('oj-enabled').addClass('oj-disabled');\n      } else {\n        // option not set to disabled. nor is parent. On refresh this is ok, since we get it from the option.\n        // when a dom element supports disabled, use that, and not aria-disabled.\n        // having both is an error.\n        this.element\n          .prop('disabled', false)\n          .removeAttr('aria-disabled')\n          .removeClass('oj-disabled')\n          .addClass('oj-enabled');\n        this.$label.addClass('oj-enabled').removeClass('oj-disabled');\n        this.$choiceItem.addClass('oj-enabled').removeClass('oj-disabled');\n      }\n    },\n    /**\n     * @override\n     * @private\n     */\n    _setOption: function (key, value) {\n      this._superApply(arguments);\n\n      if (key === 'disabled') {\n        // eslint-disable-next-line no-param-reassign\n        value = !!value;\n        this._renderDisabled(value);\n      }\n\n      if (key === 'checked') {\n        this._setCheckedOnDom(value);\n        this.setSelectedClass(value);\n      }\n    },\n    /**\n     * Returns the list of labels for the element. Most likely this will be\n     * one label, not multiple labels.\n     * We do not guarantee that the returned list is live\n     * We do not guarantee that the returned list is in document order\n     * We check a jquery selector query on <label>s with a 'for' id equal to our id starting at the document level\n     * and also as a sibling of the input (needed if documentFragment instead of document as the\n     * table/datagrid use).\n     * We do not support a label wrapping an input, so if we find that, we log an error.\n     * NOTE: The .labels DOM property does not work on most browsers, so we don't use it.\n     * e.g,\n     * <pre>\n     * <input id=\"opt3\" type=\"checkbox\" name=\"rb\" value=\"opt3\">\n     * <label for=\"opt3\">Checkbox Option 3</label>\n     * </pre>\n     * @private\n     */\n    _getLabelsForElement: function () {\n      // this looks to see if the label is wrapping the input, which we do not support\n      var $labelClosestParent = this.element.closest('label');\n\n      var id = this.element.prop('id');\n      var labelForQuery = \"label[for='\" + id + \"']\";\n      var $labelForElems = $(labelForQuery);\n      var $labelSibling;\n\n      if ($labelClosestParent.length !== 0) {\n        Logger.error(\n          \"Found a label that is an input's ancestor.\" +\n            ' This is not supported in the ojCheckboxset or ojRadioset component and the component will\\n' +\n            'not work correctly. ' +\n            \"Use a label as a sibling to the input and use the label 'for' attribute to tie the two together.\"\n        );\n      }\n\n      // make sure that the $labelClosestParent isn't also the one we found with the 'for' which would\n      // be weird, but still. If it is, remove it from the jQuery element list so we don't count it as found.\n      // e.g., <label for=\"input\"><input id=\"input\"></label> // not supported!\n      // .not() method creates a new set and leaves the original set unchanged\n      $labelForElems = $labelForElems.not($labelClosestParent);\n\n      if ($labelForElems.length === 0) {\n        // table and datagrid create their rows using documentFragment. With documentFragment\n        // the labelFor query will return []. In that case, look for the label as a sibling of\n        // the element\n        $labelSibling = this.element.siblings(labelForQuery);\n        // .add() method creates a new set and leaves the original set unchanged\n        $labelForElems = $labelForElems.add($labelSibling);\n      }\n\n      // combine these query results to return the label\n      // with the for attribute pointing to the checkbox's id.\n      return $labelForElems;\n    },\n    /**\n     * Call this before you wrap the input in a span class='oj-radiocheckbox-icon' because we\n     * are looking for the span with oj-choice-item as the parent of the input.\n     * If it isn't there, this function will add it. So it never returns null.\n     * @private\n     * @returns {Object}\n     */\n    _getChoiceItem: function () {\n      var choiceItem = null;\n      var elementParent;\n      var labelSelector;\n      var ojChoiceItemSpanString;\n      var siblingLabel;\n\n      elementParent = this.element.parent();\n      // oj-choice-row and oj-choice-row-inline have been deprecated on December 7, 2016 in\n      // version 3.0.0. Use oj-choice-item instead.\n      if (\n        elementParent &&\n        (elementParent.hasClass('oj-choice-item') ||\n          elementParent.hasClass('oj-choice-row') ||\n          elementParent.hasClass('oj-choice-row-inline'))\n      ) {\n        choiceItem = elementParent;\n      } else {\n        Logger.warn(\n          \"The radioset/checkboxset's input and label dom should be wrapped in a dom \" +\n            \"node with class 'oj-choice-item'. JET is adding this missing dom to make the component work correctly.\"\n        );\n\n        // Since we can't find the oj-choice-item, create one.\n        // It needs to wrap the input and its label (if any)\n        ojChoiceItemSpanString = \"<span class='oj-choice-item oj-choice-item-added'></span>\";\n\n        // the most common case is an <input id='foo'><label for='foo'> pair, so look for that first\n        labelSelector = \"label[for='\" + this.element.attr('id') + \"']\";\n        siblingLabel = this.element.siblings().filter(labelSelector);\n\n        if (siblingLabel.length !== 0) {\n          this.element.add(siblingLabel).wrapAll(ojChoiceItemSpanString); // @HTMLUpdateOK adding empty span for styling\n          choiceItem = this.element.parent();\n        } else {\n          this.element.wrapAll(ojChoiceItemSpanString); // @HTMLUpdateOK adding empty span for styling\n          choiceItem = this.element.parent();\n        }\n      }\n\n      return choiceItem;\n    },\n    /**\n     * Return the subcomponent node represented by the documented locator attribute values.\n     * Test authors should target spinner sub elements using the following names:\n     * <ul>\n     * <li><b>oj-radiocheckbox-input</b>: the radio/checkbox's input</li>\n     * <li><b>oj-radiocheckbox-label</b>: the radio/checkbox's label</li>\n     * </ul>\n     *\n     * @expose\n     * @override\n     * @memberof oj._ojRadioCheckbox\n     * @instance\n     * @param {Object} locator An Object containing at minimum a subId property\n     * whose value is a string, documented by the component, that allows the component to\n     * look up the subcomponent associated with that string.  It contains:\n     * <ul>\n     * <li>\n     * component: optional - in the future there may be more than one component\n     *   contained within a page element\n     * </li>\n     * <li>\n     * subId: the string, documented by the component, that the component expects\n     * in getNodeBySubId to locate a particular subcomponent\n     * </li>\n     * </ul>\n     * @returns {Element|null} the subcomponent located by the subId string\n     * passed in locator, if found.\n     */\n    getNodeBySubId: function (locator) {\n      var node = this._super(locator);\n      if (!node) {\n        var subId = locator.subId;\n        if (subId === 'oj-radiocheckbox-input') {\n          node = this.element[0];\n        }\n        if (subId === 'oj-radiocheckbox-label') {\n          // this.label() returns a jquery object. we want to return a dom element\n          node = this.label()[0];\n        }\n      }\n      // Non-null locators have to be handled by the component subclasses\n      return node || null;\n    },\n\n    /**\n     * @ignore\n     * @protected\n     * @override\n     */\n    _destroy: function () {\n      var ret = this._super();\n\n      this._RemoveHoverable(this.$choiceItem);\n      this._RemoveActiveable(this.$choiceItem);\n\n      this._RemoveHoverable(this.$label);\n      this._RemoveActiveable(this.$label);\n\n      var type = this.options.type;\n\n      // this.$label is the label for the checkbox/radio, NOT the label for the radioset/checkboxset.\n      // We don't save and restore these attributes in base class, so we need to clean up ourselves\n      if (type === 'checkbox') {\n        this.$label.removeClass('oj-enabled oj-disabled oj-selected oj-checkbox-label');\n      } else if (type === 'radio') {\n        this.$label.removeClass('oj-enabled oj-disabled oj-selected oj-radio-label');\n      }\n\n      this.$choiceItem.removeClass('oj-enabled oj-disabled oj-selected');\n\n      var self = this;\n\n      // loop through each label to remove things we added\n      $.each(self.$label, function () {\n        var text = this.getElementsByClassName('oj-radiocheckbox-label-text');\n        if (text !== undefined) {\n          $(text[0].childNodes[0]).unwrap();\n        }\n      });\n\n      // remove the oj-radiocheckbox-icon span around the element.\n      this.element.unwrap();\n\n      // remove the oj-choice-item span only if I added it.\n      // I marked it with 'oj-choice-item-added' style.\n      if (this.$choiceItem.hasClass('oj-choice-item-added')) {\n        this.element.unwrap();\n      }\n\n      this.$choiceItem = null;\n      this.$label = null;\n\n      return ret;\n    }\n\n    /** ** end internal widget functions ****/\n  });\n\n  /**\n   * @class RadioCheckboxUtils\n   * @classdesc JET Radio and Checkbox Component Utils\n   * @export\n   * @since 6.1.0\n   * @hideconstructor\n   * @ignore\n   *\n   */\n  const RadioCheckboxUtils = {};\n  oj._registerLegacyNamespaceProp('RadioCheckboxUtils', RadioCheckboxUtils);\n\n  /**\n   * Render option items from existing data.\n   *\n   * @public\n   * @ignore\n   */\n  RadioCheckboxUtils.renderOptions = function () {\n    var optionsDataArray = this._optionsDataArray;\n    var choiceset = this.element[0];\n\n    if (optionsDataArray) {\n      // The wrapper should have been created in _ComponentCreate\n      var wrapperClass =\n        choiceset.tagName === 'OJ-RADIOSET' ? 'oj-radioset-wrapper' : 'oj-checkboxset-wrapper';\n      var wrapper = choiceset.querySelector('.' + wrapperClass);\n\n      // Remove all the existing option items\n      var optionItems = wrapper.querySelectorAll('.oj-choice-item');\n      for (let i = 0; i < optionItems.length; i++) {\n        let item = optionItems[i];\n        item.parentNode.removeChild(item);\n      }\n      // When in readonly mode, unselected oj-options will be unprocessed.\n      // We need to remove them as well.\n      optionItems = wrapper.querySelectorAll('oj-option');\n      for (let i = 0; i < optionItems.length; i++) {\n        let item = optionItems[i];\n        item.parentNode.removeChild(item);\n      }\n\n      // Determine option renderer\n      var optionRenderer = this.options.optionRenderer;\n      var optionsKeys = this.options.optionsKeys;\n      var valueKey = optionsKeys && optionsKeys.value ? optionsKeys.value : 'value';\n      if (typeof optionRenderer !== 'function') {\n        // Default option renderer\n        optionRenderer = function (optionContext) {\n          var labelKey = optionsKeys && optionsKeys.label ? optionsKeys.label : 'label';\n          var disabledKey = 'disabled';\n          var ojOption = document.createElement('oj-option');\n          ojOption.value = optionContext.data[valueKey];\n          ojOption.textContent = optionContext.data[labelKey];\n          ojOption.disabled = optionContext.data[disabledKey];\n          return ojOption;\n        };\n      }\n\n      // Create all oj-option from option data\n      for (let i = 0; i < optionsDataArray.length; i++) {\n        var optionContext = {\n          component: choiceset,\n          index: i,\n          data: optionsDataArray[i]\n        };\n        var ojOption = optionRenderer(optionContext);\n        if (ojOption && ojOption.tagName === 'OJ-OPTION') {\n          // Need to set data-oj-binding-provider so that the element will be upgraded\n          if (!ojOption.hasAttribute('data-oj-binding-provider')) {\n            ojOption.setAttribute('data-oj-binding-provider', 'none');\n          }\n          if (ojOption.value === null || ojOption.value === undefined) {\n            ojOption.value = optionContext.data[valueKey];\n          }\n          wrapper.appendChild(ojOption);\n          Components.subtreeAttached(ojOption);\n        }\n      }\n\n      // Call refresh, which will set up all oj-option as _ojRadioCheckbox\n      // and update the display value and disabled state.\n      this.refresh();\n    }\n  };\n\n  /**\n   * Fetch DataProvider data and render option items from it.\n   * This is called when the component is created, when the \"options\" property changes,\n   * and when the DataProvider data is changed.\n   *\n   * @public\n   * @ignore\n   */\n  RadioCheckboxUtils.generateOptionsFromData = function () {\n    var dataProvider = this.options.options;\n\n    // Remove any existing DataProvider listeners\n    RadioCheckboxUtils.removeDataListener.call(this);\n\n    // Nothing else to do here if no DataProvider is used\n    if (!dataProvider || !oj.DataProviderFeatureChecker.isDataProvider(dataProvider)) {\n      return;\n    }\n\n    // Add a busy state\n    var desc = 'The component identified by \"' + this.element[0].id + '\" is fetching data';\n    var busyStateOptions = { description: desc };\n    var busyContext = oj.Context.getContext(this.element[0]).getBusyContext();\n    var resolveFunc = busyContext.addBusyState(busyStateOptions);\n\n    // Create a clientId symbol that uniquely identify this consumer so that\n    // DataProvider which supports it can optimize resources\n    this._clientId = this._clientId || Symbol();\n\n    // Fetch all the option data\n    // eslint-disable-next-line no-param-reassign\n    this._optionsDataArray = [];\n    var i;\n    var asyncIterator = dataProvider.fetchFirst({ clientId: this._clientId })[Symbol.asyncIterator]();\n    var self = this;\n    var processResults = function (iterResult) {\n      var nextPromise;\n\n      if (iterResult && iterResult.value) {\n        var fetchListResult = iterResult.value;\n        for (i = 0; i < fetchListResult.data.length; i++) {\n          self._optionsDataArray.push(fetchListResult.data[i]);\n        }\n\n        // fetch the next batch if we're not done\n        if (!iterResult.done) {\n          nextPromise = asyncIterator.next().then(processResults);\n        }\n      }\n\n      return nextPromise;\n    };\n\n    var fetchPromise = asyncIterator.next().then(processResults);\n\n    fetchPromise.then(\n      function () {\n        RadioCheckboxUtils.renderOptions.call(self);\n        // Add back DataProvider listeners after the options are rendered\n        RadioCheckboxUtils.addDataListener.call(self);\n        // Resolve busy state\n        resolveFunc();\n      },\n      function () {\n        resolveFunc();\n      }\n    );\n  };\n\n  /**\n   * Add listeners to DataProvider events.\n   *\n   * @public\n   * @ignore\n   */\n  RadioCheckboxUtils.addDataListener = function () {\n    // Remove any existing listener first\n    RadioCheckboxUtils.removeDataListener.call(this);\n\n    if (this.options.options && oj.DataProviderFeatureChecker.isDataProvider(this.options.options)) {\n      // Remember which dataprovider is used because this.options.options can change\n      // eslint-disable-next-line no-param-reassign\n      this._optionsDataProvider = this.options.options;\n      // eslint-disable-next-line no-param-reassign\n      this._optionsDataListener = RadioCheckboxUtils.generateOptionsFromData.bind(this);\n      this._optionsDataProvider.addEventListener('refresh', this._optionsDataListener);\n      this._optionsDataProvider.addEventListener('mutate', this._optionsDataListener);\n    }\n  };\n\n  /**\n   * Remove listeners from DataProvider events.\n   *\n   * @public\n   * @ignore\n   */\n  RadioCheckboxUtils.removeDataListener = function () {\n    if (this._optionsDataListener) {\n      this._optionsDataProvider.removeEventListener('refresh', this._optionsDataListener);\n      this._optionsDataProvider.removeEventListener('mutate', this._optionsDataListener);\n      // eslint-disable-next-line no-param-reassign\n      this._optionsDataProvider = null;\n      // eslint-disable-next-line no-param-reassign\n      this._optionsDataListener = null;\n    }\n  };\n\n});\n"],"names":["ojcomponentcore","ojeditablevalue","ojradiocheckbox","ojoption","oj","$","Logger","Translations","LabeledByUtils","__oj_checkboxset_metadata","_sValueChangeCheckFalse","Object","prototype","hasOwnProperty","call","extension","_WIDGET_NAME","_ALIASED_PROPS","readonly","_TRACK_CHILDREN","CustomElementBridge","register","metadata","CollectionUtils","mergeDeep","properties","binding","consume","name","userAssistanceDensity","labelEdge","doValueChangeCheck","__registerWidget","editableValue","version","defaultElement","widgetEventPrefix","_WRAPPER_CLASS_NAMES","options","disabled","labelledBy","readOnly","optionRenderer","optionsKeys","required","value","refresh","this","_super","_setup","widget","uiCheckboxset","validate","EditableValueUtils","_InitOptions","originalDefaults","constructorOptions","selectedCheckbox","domValue","checkedValues","_IsCustomElement","initializeOptionsFromDom","attribute","validateOption","option","coerceDomValue","_checkValueType","undefined","$checkboxes","_findCheckboxesWithMatchingName","filter","length","each","push","val","_context","writeback","internalSet","_ComponentCreate","$element","element","is","Error","uniqueId","_externalTabIndex","attr","removeAttr","RadioCheckboxUtils","generateOptionsFromData","_processOjOptions","_ojRadioCheckbox","addClass","$childNodes","contents","getAttribute","wrapAll","append","_updateReadonlyState","_on","_events","_ResetComponentState","disabledValue","prop","not","GetFocusElement","readonlyFocusElement","_GetReadonlyFocusElement","_GetContentElement","first","querySelector","_SetDisabledDom","_IsRequired","_refreshRequired","i","len","domElem","wrapperDom","renderer","_customOptionRenderer","bind","children","add","find","selectedOptionsArray","vals","opts","values","slice","optIndex","valIndex","optVal","indexOf","sortValuesInOptionsOrder","numSelected","novaluespan","parentElement","removeChild","span","document","createElement","setAttribute","noCheckboxSelected","getTranslatedString","textContent","appendChild","customOptionRenderer","_processReadonlyOptions","_initInputLabelFromOjOption","ojOption","optionValue","selectedArrayLength","get","parentSpan","parentsUntil","classList","isLastOption","_initReadonlyLabelFromOjOption","removeAttribute","elem","label","id","checkboxId","checkbox","getElementById","tagName","remove","contains","nodeName","insertBefore","ariaLabel","ariaLabelledBy","separatorNode","toggleLabelSeparator","needsSeparator","separator","isRowDirection","hasClass","oldlabel","nextElementSibling","previousSibling","_labelledByUpdatedForSet","selector","$first","warn","_NotifyContextMenuGesture","menu","event","eventType","launcher","_OpenContextMenu","_GetMessagingLauncherElement","_propagateDisabled","removeClass","change","_HandleChangeEvent","target","click","_confirmValueIsArray","Array","isArray","submittedValue","checkboxes","checked","_GetDisplayValue","_SetValue","_GetElementValue","_SetDisplayValue","displayValueArray","$checkbox","_GetOptionValue","index","_GetOptionIndex","self","selectedCheckboxes","optionValueArray","matchIndex","compareValues","checkboxElem","_GetDefaultStyleClass","_AriaRequiredUnsupported","_ShowHelpHintsLocation","_AfterSetOptionRequired","_disabled","data","__setAncestorComponentDisabled","_setOption","key","flags","originalValue","renderOptions","_AfterSetOption","previous","_superApply","arguments","getNodeBySubId","locator","node","subId","arrayLength","checkboxValues","getSubIdByNode","topElem","currentNode","for","_destroy","ret","firstElementChild","unwrap","removeDataListener","Components","baseComponent","type","$label","_getLabelsForElement","refreshDisabled","_renderDisabled","setSelectedClass","toggleClass","$choiceItem","uiRadioCheckbox","checkedFromDom","disabledFromDom","initCheckedFromDom","_getChoiceItem","iElem","_focusable","_AddHoverable","_AddActiveable","applyHighlight","childNodes","_SaveAttributes","_savedClasses","_RestoreAttributes","_setCheckedOnDom","_IsEffectivelyDisabled","$labelSibling","$labelClosestParent","closest","labelForQuery","$labelForElems","error","siblings","elementParent","labelSelector","ojChoiceItemSpanString","siblingLabel","choiceItem","parent","_RemoveHoverable","_RemoveActiveable","text","getElementsByClassName","_registerLegacyNamespaceProp","optionsDataArray","_optionsDataArray","choiceset","wrapperClass","wrapper","optionItems","querySelectorAll","item","parentNode","valueKey","optionContext","labelKey","component","hasAttribute","subtreeAttached","dataProvider","DataProviderFeatureChecker","isDataProvider","busyStateOptions","description","resolveFunc","Context","getContext","getBusyContext","addBusyState","_clientId","Symbol","asyncIterator","fetchFirst","clientId","processResults","iterResult","nextPromise","fetchListResult","done","next","then","addDataListener","_optionsDataProvider","_optionsDataListener","addEventListener","removeEventListener"],"sourceRoot":""}